<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Blog posts from Antonis Stampoulis</title>
    <link>https://astampoulis.github.io/</link>
    <description>Recent posts on Antonis Stampoulis</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <managingEditor>antonis DOT stampoulis AT gmail DOT com (Antonis Stampoulis)</managingEditor>
    <webMaster>antonis DOT stampoulis AT gmail DOT com (Antonis Stampoulis)</webMaster>
    <lastBuildDate>Fri, 01 May 2020 17:30:00 -0400</lastBuildDate>
    <atom:link href="/" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>A language design taksim on mode declarations for Makam</title>
      <link>https://astampoulis.github.io/blog/taksim-modes-makam/</link>
      <pubDate>Fri, 01 May 2020 17:30:00 -0400</pubDate>
      <author>antonis DOT stampoulis AT gmail DOT com (Antonis Stampoulis)</author>
      <guid>https://astampoulis.github.io/blog/taksim-modes-makam/</guid>
      <description>&lt;p&gt;In this post, we will explore a few design ideas related to integrating mode declarations into Makam, using bidirectional typing as an example. This feature is still in the design phase, so I&amp;rsquo;d be glad to hear comments and ideas!&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h2 id=&#34;todo&#34;&gt;todo&lt;/h2&gt;

&lt;p&gt;This post is WIP. To keep track of updates, follow this &lt;a href=&#34;https://github.com/astampoulis/website-source/pull/2&#34;&gt;PR&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&#34;intro&#34;&gt;intro&lt;/h2&gt;

&lt;p&gt;Recommended soundtrack: &lt;a href=&#34;https://open.spotify.com/album/1Agh6GiahtO2bt4t5zLJR2&#34;&gt;Kalthoum (Alf Leila Wa Leila), by Ibrahim Maalouf&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Thoughts for this post came from reading &lt;a href=&#34;http://research.cs.queensu.ca/home/joshuad/&#34;&gt;J. Dunfield&lt;/a&gt; and &lt;a href=&#34;https://semantic-domain.blogspot.com/&#34;&gt;Neel Krishnaswami&lt;/a&gt;&amp;rsquo;s &lt;a href=&#34;https://arxiv.org/abs/1908.05839&#34;&gt;survey on bidirectional typing&lt;/a&gt;, as well as other discussions.&lt;/p&gt;

&lt;p&gt;You can run the code in this post in your browser, through the
Makam Web UI. Click on the play button on the bottom-right corner, or press Ctrl+Enter!&lt;/p&gt;

&lt;h2 id=&#34;setup&#34;&gt;setup&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-makam-hidden&#34;&gt;tests : testsuite. %testsuite tests.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;One of the distinguishing characteristics of logic programming languages is being able to use predicates in multiple modes.
The same predicate can be used both for computing what is typically the output parameter, or what is typically an input parameter&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:1&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:1&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;.
For example, &lt;code&gt;append&lt;/code&gt; can be used both to append one list to another, but also to find which list we need to append to one to get a certain result:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-makam&#34;&gt;append [1, 2, 3] [4, 5, 6] Result ?
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-makam-hidden&#34;&gt;&amp;gt;&amp;gt; Yes:
&amp;gt;&amp;gt; Result := [1, 2, 3, 4, 5, 6].
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-makam&#34;&gt;append [1, 2, 3] InputList2 [1, 2, 3, 4, 5] ?
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-makam-hidden&#34;&gt;&amp;gt;&amp;gt; Yes:
&amp;gt;&amp;gt; InputList2 := [4, 5].
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Still, in many cases, it is useful to be able to specify and restrict the modes under which a predicate is used.
This is especially useful when we are trying to accurately model existing type inferencing algorithms.
This comes up in bidirectional typing for example, where we have two different typing judgments with different modes:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;$\Gamma \vdash e \Rightarrow \tau$, the type &lt;em&gt;synthesis&lt;/em&gt; or type &lt;em&gt;inference&lt;/em&gt; judgment, where the type $\tau$ is unknown and is being synthesized from $e$&lt;/li&gt;
&lt;li&gt;$\Gamma \vdash e \Leftarrow \tau$, the type &lt;em&gt;analysis&lt;/em&gt; or type &lt;em&gt;checking&lt;/em&gt; judgment, where the type $\tau$ is known and is being checked against $e$&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-makam-hidden&#34;&gt;expr : type.
typ : type.

annot : expr -&amp;gt; typ -&amp;gt; expr.
eunit : expr.
lambda : (expr -&amp;gt; expr) -&amp;gt; expr.
app : expr -&amp;gt; expr -&amp;gt; expr.

tunit : typ.
arrow : typ -&amp;gt; typ -&amp;gt; typ.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Modeling these judgments as predicates in λProlog/Makam, their types are the same:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-makam-noeval&#34;&gt;type_synth : expr -&amp;gt; typ -&amp;gt; prop.
type_check : expr -&amp;gt; typ -&amp;gt; prop.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;However, the two predicates differ in terms of how they are supposed to be used. In both of them, the expression argument is supposed to be known, so it&amp;rsquo;s an input parameter; in the analysis predicate, the type is an input parameter; whereas in the synthesis predicate, the type argument is an output parameter, since it is unknown and what the predicate will compute.&lt;/p&gt;

&lt;p&gt;To capture this intention of how predicates are supposed to be used, &lt;em&gt;mode declarations&lt;/em&gt; are common in logic programming (and higher-order logic programming) languages; in that way, we can turn off the &amp;ldquo;generative&amp;rdquo; behavior of predicates for input parameters. These could look something like this, using informal syntax:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;mode type_synth (input output).
mode type_check (input input).
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Makam does not support mode declarations though. This brings us to the main thing we&amp;rsquo;ll explore in this post: can we add support for them, without changing the core language?&lt;/p&gt;

&lt;p&gt;Here&amp;rsquo;s the structure of the rest of this.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;What happens if we transcribe the bidirectional system for the STLC directly? &lt;a href=&#34;#example-naively&#34;&gt;→ example, naively&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;How can we model bidirectional typing accurately? &lt;a href=&#34;#example-manually&#34;&gt;→ example, manually&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;It would be nice to be able to fix this just by adding a mode declaration for &lt;code&gt;type_synth&lt;/code&gt; and &lt;code&gt;type_check&lt;/code&gt;. Can we add mode declarations to Makam? Is there a way to do this without changing the core language? &lt;a href=&#34;#modal-makam&#34;&gt;→ modal makam&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Do simple mode declarations provide enough generality? (TODO) &lt;a href=&#34;#todo&#34;&gt;→ modal makam, take 2&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Can we turn the bidirectional recipe into a Makam program, to &amp;ldquo;bidirectionalize&amp;rdquo; an existing typing declaration? (TODO) &lt;a href=&#34;#todo&#34;&gt;→ writing recipes in makam&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;example-naively&#34;&gt;example, naively&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-makam-hidden&#34;&gt;type_of_var : expr -&amp;gt; typ -&amp;gt; prop.
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-makam-hidden&#34;&gt;%extend naive.
type_synth : expr -&amp;gt; typ -&amp;gt; prop.
type_check : expr -&amp;gt; typ -&amp;gt; prop.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As a first step, let&amp;rsquo;s look at the basic bidirectional typing rules for the simply-typed lambda calculus, and try to transcribe them directly to Makam. Following the definitions in the &lt;a href=&#34;https://arxiv.org/pdf/1908.05839&#34;&gt;survey&lt;/a&gt; paper mentioned above (Figure 1), the rules are:&lt;/p&gt;

&lt;p&gt;&lt;center&gt;&lt;img src=&#34;https://astampoulis.github.io/blog/taksim-modes-bidir-spec.svg&#34; alt=&#34;Abstract syntax tree&#34; width=&#34;500&#34; /&gt;&lt;/center&gt;&lt;/p&gt;

&lt;p&gt;Transcribing them to Makam should be simple:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-makam&#34;&gt;type_synth X A :-
  type_of_var X A.

type_check E B :-
  type_synth E A, unify A B.

type_synth (annot E A) A :-
  type_check E A.

type_check eunit tunit.

type_check (lambda E) (arrow A1 A2) :-
  (x:expr -&amp;gt; type_of_var x A1 -&amp;gt; type_check (E x) A2).

type_synth (app E1 E2) B :-
  type_synth E1 (arrow A B),
  type_check E1 A.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here I am using the additional predicate &lt;code&gt;type_of_var&lt;/code&gt; to model the context $\Gamma$.&lt;/p&gt;

&lt;p&gt;This seems to work:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-makam&#34;&gt;type_check (lambda (fun x =&amp;gt; x)) (arrow tunit tunit) ?
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-makam-hidden&#34;&gt;&amp;gt;&amp;gt; Yes.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As we expect though, this does not model the bidirectional system accurately. For example,
it is able to discover a type &lt;code&gt;T&lt;/code&gt; when we are using the type-checking judgment:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-makam&#34;&gt;type_check (lambda (fun x =&amp;gt; x)) T ?
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-makam-hidden&#34;&gt;&amp;gt;&amp;gt; Yes:
&amp;gt;&amp;gt; T := arrow T1 T1.
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-makam-hidden&#34;&gt;%end.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;An accurate model of the bidirectional system should fail instead,
as the type &lt;code&gt;T&lt;/code&gt; is unknown and can thus not be used with the
type-checking judgment.&lt;/p&gt;

&lt;p&gt;So instead, let&amp;rsquo;s try to transcribe the system more accurately.&lt;/p&gt;

&lt;h2 id=&#34;example-manually&#34;&gt;example, manually&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-makam-hidden&#34;&gt;%extend manual.
type_check : expr -&amp;gt; typ -&amp;gt; prop.
type_synth : expr -&amp;gt; typ -&amp;gt; prop.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To start, let us focus on just one indicative checking rule:&lt;/p&gt;

&lt;p&gt;&lt;center&gt;&lt;img src=&#34;https://astampoulis.github.io/blog/taksim-modes-bidir-focused.svg&#34; alt=&#34;Abstract syntax tree&#34; width=&#34;300&#34; /&gt;&lt;/center&gt;&lt;/p&gt;

&lt;p&gt;To encode this rule properly, we need to make sure
that the type &lt;code&gt;T&lt;/code&gt; of &lt;code&gt;type_check E T&lt;/code&gt; is treated as an input.
The key difference is that
given an unknown type like &lt;code&gt;T&lt;/code&gt; as input, we should not unify it with the
&lt;code&gt;arrow A1 A2&lt;/code&gt; term; instead, we should check that &lt;code&gt;T&lt;/code&gt; &lt;em&gt;already&lt;/em&gt;
looks like &lt;code&gt;arrow A1 A2&lt;/code&gt;. So we should perform &lt;em&gt;pattern matching&lt;/em&gt;
rather than &lt;em&gt;unification&lt;/em&gt; with &lt;code&gt;arrow A1 A2&lt;/code&gt;. Fortunately,
Makam provides us with a &lt;code&gt;pattern_match&lt;/code&gt; implementation that behaves
as expected:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-makam&#34;&gt;unify (arrow A1 A2) T ?
pattern_match (arrow A1 A2) T ?
pattern_match (arrow A1 A2) (arrow tunit tunit) ?
pattern_match (arrow A1 A2) (arrow C D) ?
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-makam-hidden&#34;&gt;&amp;gt;&amp;gt; unify (arrow A1 A2) T ?
&amp;gt;&amp;gt; Yes:
&amp;gt;&amp;gt; T := arrow A1 A2, A1 := A1, A2 := A2.

&amp;gt;&amp;gt; pattern_match (arrow A1 A2) T ?
&amp;gt;&amp;gt; Impossible.

&amp;gt;&amp;gt; pattern_match (arrow A1 A2) (arrow tunit tunit) ?
&amp;gt;&amp;gt; Yes:
&amp;gt;&amp;gt; A1 := tunit, A2 := tunit.

&amp;gt;&amp;gt; pattern_match (arrow A1 A2) (arrow C D) ?
&amp;gt;&amp;gt; Yes:
&amp;gt;&amp;gt; A1 := C, A2 := D, C := C, D := D.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;(The first argument to &lt;code&gt;pattern_match&lt;/code&gt; is the pattern, and the second is the scrutinee).&lt;/p&gt;

&lt;p&gt;So encoding the arrow introduction rule accurately is simple &amp;ndash; we
can just use &lt;code&gt;pattern_match&lt;/code&gt; instead of unifying directly:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-makam&#34;&gt;type_check (lambda E) T :-
  pattern_match (arrow A1 A2) T,
  (x:expr -&amp;gt; type_of_var x A1 -&amp;gt; type_check (E x) A2).
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To be entirely accurate, we should use pattern matching for the
expression argument, since we expect that to be an input too. But
we&amp;rsquo;ll keep that as-is for now and revisit that later.&lt;/p&gt;

&lt;p&gt;Transcribing the rest of the rules, we proceed similarly for the
checking rules, and there is not much we need to change for synthesis rules.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-makam&#34;&gt;type_synth X A :-
  type_of_var X A.

type_check E B :-
  type_synth E A, unify A B.

type_synth (annot E A) A :-
  type_check E A.

type_check eunit T :-
  pattern_match tunit T.

type_synth (app E1 E2) B :-
  type_synth E1 (arrow A B),
  type_check E1 A.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Let&amp;rsquo;s try a few examples to see what we did:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-makam&#34;&gt;type_check (lambda (fun x =&amp;gt; x)) (arrow tunit tunit) ?
type_check (lambda (fun x =&amp;gt; x)) T ?
type_check (lambda (fun x =&amp;gt; x)) (arrow tunit X) ?
type_check (lambda (fun x =&amp;gt; x)) (arrow tunit (arrow tunit tunit)) ?
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;These all behave as expected.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-makam-hidden&#34;&gt;&amp;gt;&amp;gt; type_check (lambda (fun x =&amp;gt; x)) (arrow tunit tunit) ?
&amp;gt;&amp;gt; Yes.

&amp;gt;&amp;gt; type_check (lambda (fun x =&amp;gt; x)) T ?
&amp;gt;&amp;gt; Impossible.

&amp;gt;&amp;gt; type_check (lambda (fun x =&amp;gt; x)) (arrow tunit X) ?
&amp;gt;&amp;gt; Yes:
&amp;gt;&amp;gt; X := tunit.

&amp;gt;&amp;gt; type_check (lambda (fun x =&amp;gt; x)) (arrow (arrow tunit tunit) X) ?
&amp;gt;&amp;gt; Yes:
&amp;gt;&amp;gt; X := arrow tunit tunit.

&amp;gt;&amp;gt; type_check (lambda (fun x =&amp;gt; x)) (arrow tunit (arrow tunit tunit)) ?
&amp;gt;&amp;gt; Impossible.
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-makam-hidden&#34;&gt;%end.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So the recipe for enforcing a proper mode is pretty simple: for input arguments, we should use pattern matching rather than unification.
Is there some way that we can extend Makam to support this recipe?&lt;/p&gt;

&lt;h2 id=&#34;modal-makam&#34;&gt;modal makam&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-makam-hidden&#34;&gt;(* stdlib extensions required for this. will open a PR for Makam soon *)

%extend refl.

decompose_term : [Full Head] Full -&amp;gt; Head -&amp;gt; args Head Full -&amp;gt; prop.
decompose_term Term Head Args :-
  refl.headargs Term Head ArgsDyn,
  dyn.to_args ArgsDyn Args.

recompose_term : [Full Head] Head -&amp;gt; args Head Full -&amp;gt; Full -&amp;gt; prop.
recompose_term Head Args Term :-
  args.applyfull Head Args Term.

%end.
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-makam-hidden&#34;&gt;%extend modes_v1.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here&amp;rsquo;s a first approach: we can do some meta-programming in Makam, transforming predicates that utilize a specific mode according to the recipe. We will have to perform that transformation for all rules of the relevant predicates.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s see how this would work. First of all, we can define &lt;code&gt;mode&lt;/code&gt; as a predicate, that will be used to specify the mode for predicates. We&amp;rsquo;ll make light use of GADTs to make sure that when specifying a mode, the number of arguments we specify matches the number of arguments of the predicate.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-makam&#34;&gt;argument_mode : type.
input, output : argument_mode.

mode_spec : type -&amp;gt; type.
nil : mode_spec prop.
cons : argument_mode -&amp;gt; mode_spec B -&amp;gt; mode_spec (A -&amp;gt; B).

mode : [A] A -&amp;gt; mode_spec A -&amp;gt; prop.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now we should be able to specify modes for our predicates:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-makam&#34;&gt;type_check : expr -&amp;gt; typ -&amp;gt; prop.
mode type_check [input, input].

type_synth : expr -&amp;gt; typ -&amp;gt; prop.
mode type_synth [input, output].
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now let&amp;rsquo;s work on the actual clause transformation. A clause like the following:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-makam-noeval&#34;&gt;type_check (lambda E) (arrow A1 A2) :-
  (x:expr -&amp;gt; type_of_var x A1 -&amp;gt; type_check (E x) A2).
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;should be turned to:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-makam-noeval&#34;&gt;type_check Arg1 Arg2 :-
  pattern_match (lambda E) Arg1,
  pattern_match (arrow A1 A2) Arg2,
  (x:expr -&amp;gt; type_of_var x A1 -&amp;gt; type_check (E x) A2).
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Desugaring, the above clauses correspond to the following Makam terms:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-makam-noeval&#34;&gt;clause (type_check (lambda E) (arrow A1 A2))
  (newvar (fun (x:expr) =&amp;gt;
    (assume (clause (type_of_var x A1) success)
      (type_check (E x) A2))))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;and after transformation:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-makam-noeval&#34;&gt;clause (type_check Arg1 Arg2)
  (and_many
    [ pattern_match (lambda E) Arg1,
      pattern_match (arrow A1 A2) Arg2,
      newvar (fun (x:expr) =&amp;gt;
        (assume (clause (type_of_var x A1) success)
          (type_check (E x) A2))) ])
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Let&amp;rsquo;s write a predicate to do that transformation:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-makam&#34;&gt;generate_matches :
  [A] mode_spec A -&amp;gt;
      args A prop -&amp;gt; args A prop -&amp;gt; list prop -&amp;gt; prop.

mode_transform : clause -&amp;gt; clause -&amp;gt; prop.
mode_transform
    (clause Goal Premise)
    (clause Goal&#39; (and_many MatchesAndPremise)) :-
  refl.decompose_term Goal Predicate Patterns,
  refl.recompose_term Predicate Args Goal&#39;,
  mode Predicate ModeSpec,
  generate_matches ModeSpec Patterns Args Matches,
  append Matches [Premise] MatchesAndPremise.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;OK, there&amp;rsquo;s a lot going on in these few lines:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;We use &lt;code&gt;refl.decompose_term&lt;/code&gt; to decompose a term into its head and arguments, turning &lt;code&gt;type_check (lambda E) (arrow A1 A2)&lt;/code&gt; into
&lt;code&gt;type_check&lt;/code&gt; (the head, which in this case is the &lt;code&gt;Predicate&lt;/code&gt;) and &lt;code&gt;[lambda E, arrow A1 A2]&lt;/code&gt; (the arguments, which in this case are the &lt;code&gt;Patterns&lt;/code&gt; we are interested in).&lt;/li&gt;
&lt;li&gt;We use &lt;code&gt;refl.recompose_term&lt;/code&gt; to recompose a term from a head and arguments. Since &lt;code&gt;Args&lt;/code&gt; is not concrete, this will generate turn it into a list of new unification variables, giving us a term like &lt;code&gt;type_check Arg1 Arg2&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;We look up the mode specification of the &lt;code&gt;Predicate&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;We use &lt;code&gt;generate_matches&lt;/code&gt; to zip together the patterns and the new unification variables into the corresponding propositions, following the mode specification. This will give us a term like &lt;code&gt;pattern_match (lambda E) Arg1&lt;/code&gt; for the first pattern and argument.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The rules for &lt;code&gt;generate_matches&lt;/code&gt; are as follows:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-makam&#34;&gt;generate_matches [] [] [] [].
generate_matches
    (input :: Modes)
    (Pattern :: Patterns)
    (Arg :: Args)
    ((pattern_match Pattern Arg) :: Rest) :-
  generate_matches Modes Patterns Args Rest.
generate_matches
    (output :: Modes)
    (Pattern :: Patterns)
    (Arg :: Args)
    ((unify Pattern Arg) :: Rest) :-
  generate_matches Modes Patterns Args Rest.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Let&amp;rsquo;s see what we did:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-makam&#34;&gt;mode_transform
  (clause (type_check (lambda E) (arrow A1 A2))
    (newvar (fun x =&amp;gt;
      (assume (clause (type_of_var x A1) success)
        (type_check (E x) A2)))))
  Transformed ?
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-makam-hidden&#34;&gt;&amp;gt;&amp;gt; Yes:
&amp;gt;&amp;gt; Transformed :=
     clause (type_check Arg1 Arg2)
       (and_many
         [ pattern_match (lambda E) Arg1,
           pattern_match (arrow A1 A2) Arg2,
           newvar (fun (x:expr) =&amp;gt;
             (assume (clause (type_of_var x A1) success)
               (type_check (E x) A2))) ]).
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If we squint away the poor naming of the new unification variables,
the result looks OK! Does this work OK for output arguments too?&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-makam&#34;&gt;mode_transform
  (clause (type_synth (annot E A) A)
    (type_check E A))
  Transformed ?
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-makam-hidden&#34;&gt;&amp;gt;&amp;gt; Yes:
&amp;gt;&amp;gt; Transformed := clause (type_synth Arg1 Arg2) (and_many [ (pattern_match (annot E A) Arg1), (unify A Arg2), (type_check E A) ]).
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This introduces an extra unification variable that is not strictly needed, but the behavior should still be as expected.&lt;/p&gt;

&lt;p&gt;So the transformation based on modes seems to work OK. Now, there&amp;rsquo;s two ways we can use this transformation to make use of modes for our predicates:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#statically&#34;&gt;statically&lt;/a&gt;: when defining a new rule for a predicate that includes a mode. We can do this using the staging support of Makam: instead of defining the rules directly, we&amp;rsquo;ll call a predicate that generates a new rule, using the transformation we just defined.&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#dynamically&#34;&gt;dynamically&lt;/a&gt;: we can perform the transformation whenever the rules are about to get used. We can do this using the reflection support of Makam: we&amp;rsquo;ll define a wrapper that performs reflection to get all the rules of the predicates, do the transformation,&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;statically&#34;&gt;statically&lt;/h4&gt;

&lt;p&gt;Let&amp;rsquo;s see how those work. For the &lt;em&gt;static&lt;/em&gt; version, we will need a predicate that takes the goal and the premise of a rule, and generates
a &lt;em&gt;command&lt;/em&gt;: one of the top-level definitions that make up a Makam
program. Using our transformation predicate above, we&amp;rsquo;ll turn the goal and the premise into the clause that takes the mode specification into account, and we will generate the command to define this as a new clause:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-makam&#34;&gt;define_with_mode : prop -&amp;gt; prop -&amp;gt; cmd -&amp;gt; prop.
define_with_mode Goal Premise (cmd_newclause Clause&#39;) :-
  mode_transform (clause Goal Premise) Clause&#39;.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now we have to change how we write our rules for &lt;code&gt;type_check&lt;/code&gt; and &lt;code&gt;type_synth&lt;/code&gt;. Here&amp;rsquo;s an example:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-makam-hidden&#34;&gt;%extend static.
type_check : expr -&amp;gt; typ -&amp;gt; prop.
mode type_check [input, input].

type_synth : expr -&amp;gt; typ -&amp;gt; prop.
mode type_synth [input, output].

`(define_with_mode
  (type_synth X A)
  (type_of_var X A)).

`(define_with_mode (type_check E B)
  {prop| type_synth E A, unify A B |}).

`(define_with_mode (type_synth (annot E A) A)
  (type_check E A)).

`(define_with_mode (type_check eunit tunit) success).
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-makam&#34;&gt;`(define_with_mode (type_check (lambda E) (arrow A1 A2))
  {prop| (x:expr -&amp;gt; type_of_var x A1 -&amp;gt; type_check (E x) A2) |}).
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Having to write rules in this syntax is unfortunate and error-prone.
We have to use &lt;code&gt;{prop|&lt;/code&gt; to use propositional syntax for the premise, and we also have to remember to use &lt;code&gt;define_with_mode&lt;/code&gt;; nothing
is preventing us from writing the rules using the normal syntax, but
the mode specification will not be taken into account if we do that.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-makam-hidden&#34;&gt;`(define_with_mode (type_synth (app E1 E2) B)
  {prop|
    type_synth E1 (arrow A B),
    type_check E1 A |}).

&amp;gt;&amp;gt; type_check (lambda (fun x =&amp;gt; x)) (arrow tunit tunit) ?
&amp;gt;&amp;gt; Yes.

&amp;gt;&amp;gt; type_check (lambda (fun x =&amp;gt; x)) T ?
&amp;gt;&amp;gt; Impossible.

&amp;gt;&amp;gt; type_check (lambda (fun x =&amp;gt; x)) (arrow tunit X) ?
&amp;gt;&amp;gt; Yes:
&amp;gt;&amp;gt; X := tunit.

&amp;gt;&amp;gt; type_check (lambda (fun x =&amp;gt; x)) (arrow (arrow tunit tunit) X) ?
&amp;gt;&amp;gt; Yes:
&amp;gt;&amp;gt; X := arrow tunit tunit.

&amp;gt;&amp;gt; type_check (lambda (fun x =&amp;gt; x)) (arrow tunit (arrow tunit tunit)) ?
&amp;gt;&amp;gt; Impossible.

%end.
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;dynamically&#34;&gt;dynamically&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-makam-hidden&#34;&gt;%extend dynamic.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Let&amp;rsquo;s see how the dynamic version works out. The main thing we&amp;rsquo;ll do is to use reflection to get all the rules associated with a predicate and then write a small special interpreter for them: we&amp;rsquo;ll first transform them using &lt;code&gt;mode_transform&lt;/code&gt; and then mimic what Makam
does normally for rules:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-makam-hidden&#34;&gt;run_with_modes : prop -&amp;gt; prop.
run_clauses_with_modes : prop -&amp;gt; list clause -&amp;gt; prop.
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-makam&#34;&gt;run_with_modes Goal :-
  refl.rules_get Goal Clauses,
  run_clauses_with_modes Goal Clauses.

run_clauses_with_modes Goal (ActualRule :: Rest) :-
  mode_transform ActualRule (clause Goal&#39; Premise&#39;),
  ((unify Goal Goal&#39;, Premise&#39;)
   ; run_clauses_with_modes Goal Rest).
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The reflective predicate &lt;code&gt;refl.rules_get&lt;/code&gt; is what gives us the rules associated with a proposition as a list of clauses. Then
for each rule, &lt;code&gt;run_clauses_with_modes&lt;/code&gt; transforms it, tries
to unify our current goal with the transformed goal of the rule,
and then runs the transformed premise. It also inserts a backtracking
point to try the rest of the rules using the &lt;code&gt;or&lt;/code&gt; connective, written
as &lt;code&gt;;&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Now to use this for our typing rules, we still have to do some work:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;we have to move all of our &amp;ldquo;real&amp;rdquo; rules from &lt;code&gt;type_check&lt;/code&gt; and &lt;code&gt;type_synth&lt;/code&gt; into separate predicates &lt;code&gt;type_check_rules&lt;/code&gt; and &lt;code&gt;type_synth_rules&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;we have to change the &lt;code&gt;type_check&lt;/code&gt; and &lt;code&gt;type_synth&lt;/code&gt; predicates to be helper predicates that use &lt;code&gt;run_with_modes&lt;/code&gt; with the &amp;ldquo;real&amp;rdquo; rules&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Here&amp;rsquo;s the basic setup we&amp;rsquo;ll need:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-makam&#34;&gt;type_check_rules : expr -&amp;gt; typ -&amp;gt; prop.
mode type_check_rules [input, input].

type_synth_rules : expr -&amp;gt; typ -&amp;gt; prop.
mode type_synth_rules [input, output].

type_check : expr -&amp;gt; typ -&amp;gt; prop.
type_check E T :-
  run_with_modes (type_check_rules E T).

type_synth : expr -&amp;gt; typ -&amp;gt; prop.
type_synth E T :-
  run_with_modes (type_synth_rules E T).
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The good news is that in this case, we will be able to write the rules in a relatively normal way. I&amp;rsquo;m giving the full rules here, which I copy-pasted from our naive transcription above, and just moved them to the &lt;code&gt;_rules&lt;/code&gt; predicates:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-makam&#34;&gt;type_synth_rules X A :-
  type_of_var X A.

type_check_rules E B :-
  type_synth E A, unify A B.

type_synth_rules (annot E A) A :-
  type_check E A.

type_check_rules eunit tunit.

type_check_rules (lambda E) (arrow A1 A2) :-
  (x:expr -&amp;gt; type_of_var x A1 -&amp;gt; type_check (E x) A2).

type_synth_rules (app E1 E2) B :-
  type_synth E1 (arrow A B),
  type_check E1 A.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Of course, even in this solution there is a little bit of definition overhead: we have to remember to define the wrapper predicates, to
make sure we add the &amp;ldquo;real&amp;rdquo; rules to the &lt;code&gt;_rules&lt;/code&gt; predicates, and to
call the wrapper predicates recursively in the premises rather than the &lt;code&gt;_rules&lt;/code&gt; predicates. And there definitely is runtime overhead in this solution, as we perform the mode transformation every time that the predicates get used.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-makam-hidden&#34;&gt;&amp;gt;&amp;gt; type_check (lambda (fun x =&amp;gt; x)) (arrow tunit tunit) ?
&amp;gt;&amp;gt; Yes.

&amp;gt;&amp;gt; type_check (lambda (fun x =&amp;gt; x)) T ?
&amp;gt;&amp;gt; Impossible.

&amp;gt;&amp;gt; type_check (lambda (fun x =&amp;gt; x)) (arrow tunit X) ?
&amp;gt;&amp;gt; Yes:
&amp;gt;&amp;gt; X := tunit.

&amp;gt;&amp;gt; type_check (lambda (fun x =&amp;gt; x)) (arrow (arrow tunit tunit) X) ?
&amp;gt;&amp;gt; Yes:
&amp;gt;&amp;gt; X := arrow tunit tunit.

&amp;gt;&amp;gt; type_check (lambda (fun x =&amp;gt; x)) (arrow tunit (arrow tunit tunit)) ?
&amp;gt;&amp;gt; Impossible.
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-makam-hidden&#34;&gt;%end.
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;recap-and-future&#34;&gt;recap and future&lt;/h4&gt;

&lt;p&gt;We have found a couple of ways to take mode specifications into account without having to change the core of Makam. Unfortunately, none of these two solutions are ideal:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;doing the mode transformation statically is nice because there&amp;rsquo;s no runtime overhead every time we call the rules. However, we have to remember to use &lt;code&gt;define_with_mode&lt;/code&gt; for predicates that include a mode specification, and we have to give up on writing rules for our predicates natively. Additionally, it is hard to inspect the output of staging and understand what rules actually constitute the program.&lt;/li&gt;
&lt;li&gt;doing the transformation dynamically is nice because we can write the rules in the standard way. However, there is a significant runtime overhead, and debugging predicates written in this style becomes much harder.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;So it turns out that we might need some additional support in the core
of Makam for mode declarations to be nice. One idea there is that we
could add a way to register &amp;ldquo;rule transformer&amp;rdquo; predicates that run
whenever we add a new rule. This would be similar to the staging
approach, but would have better ergonomics: we could register the mode transformation once, proceed to write all the rules
in the normal style, and the staged transformation would happen behind
the scenes. Still, there&amp;rsquo;s a few design questions for this feature:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;should we run transformers retroactively for existing rules?&lt;/li&gt;
&lt;li&gt;how would multiple transformers work out?&lt;/li&gt;
&lt;li&gt;could we have a nice way in an IDE to switch between the pre-transformation rules and the post-transformation rules?&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Still, one good thing that we found is that the mode specification part itself looks quite nice and does not need to be part of the core language. Are these kinds of mode specifications general enough though?&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-makam-hidden&#34;&gt;%end.
&lt;/code&gt;&lt;/pre&gt;
&lt;div class=&#34;footnotes&#34;&gt;

&lt;hr /&gt;

&lt;ol&gt;
&lt;li id=&#34;fn:1&#34;&gt;In Makam unfortunately the usefulness of this feature is limited for programming language settings, due to the naive depth-first search procedure used. For great examples of this in a PL context, look at &lt;a href=&#34;http://io.livecode.ch/learn/gregr/icfp2017-artifact-auas7pp&#34;&gt;A Unified Approach to Solving Seven Programming Problems&lt;/a&gt; by William Byrd et al.
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:1&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;</description>
    </item>
    
    
    
    <item>
      <title>Makam Tutorial 1: Prototyping a toy language and its interpreter</title>
      <link>https://astampoulis.github.io/blog/makam-tutorial-01/</link>
      <pubDate>Mon, 19 Mar 2018 18:16:01 -0400</pubDate>
      <author>antonis DOT stampoulis AT gmail DOT com (Antonis Stampoulis)</author>
      <guid>https://astampoulis.github.io/blog/makam-tutorial-01/</guid>
      <description>

&lt;p&gt;&lt;em&gt;In this post, we&amp;rsquo;ll implement a toy interpreter for a small functional language. We will use Makam,
a metalanguage that helps in the &amp;lsquo;initial spiking/prototyping phase&amp;rsquo; of designing a new language, allowing
for a tight feedback loop and for iterating quickly.&lt;/em&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-makam-hidden&#34;&gt;tests : testsuite. %testsuite tests.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Say you are designing and implementing a new language: there is a class of programs that are
hard to write in languages that are presently available and you want better ways to express them.&lt;/p&gt;

&lt;p&gt;There are a lot of decisions to make. For starters, &lt;em&gt;what should the constructs of the language
be&lt;/em&gt;?  How do these constructs enable writing the example programs that you have in mind? Which
constructs should be the &amp;ldquo;core&amp;rdquo; ones of the language, and which ones should be defined in terms of
them?&lt;/p&gt;

&lt;p&gt;What does it mean to use the language? How do you write programs in it — what&amp;rsquo;s the syntax like,
what information can one get about their programs (and how much of it can be inferred)?  What do the
constructs of the language mean — how do you compute with them, how do they relate to the
constructs in existing languages?&lt;/p&gt;

&lt;p&gt;Coming up with answers to these questions is an iterative process: you can start with some answers,
try to write example programs, see what works and what does not, and adapt accordingly. Implementing
the language is quite crucial to this process: actually using the language reveals patterns that are
important but that you couldn&amp;rsquo;t necessarily have found otherwise — so that informs how to refine
the language further and what constructs to add.&lt;/p&gt;

&lt;p&gt;Still, implementing a language takes a long time, which hinders this experimentation and refinement
process. There is &lt;em&gt;typically&lt;/em&gt; a long feedback loop involved between having a new language design idea and
having a working (even toy-ish) implementation of it&amp;hellip; but there doesn&amp;rsquo;t have to be!&lt;/p&gt;

&lt;p&gt;Minimizing this feedback loop is exactly why I have been working on the design and implementation of
&lt;strong&gt;Makam&lt;/strong&gt;, a &lt;strong&gt;metalanguage&lt;/strong&gt; that helps with the design and implementation of (prototypes of) new
languages. This way it allows you to iterate, validate and refine your language ideas quickly.&lt;/p&gt;

&lt;p&gt;Makam is a dialect of &lt;a href=&#34;http://www.lix.polytechnique.fr/~dale/lProlog/&#34;&gt;λProlog&lt;/a&gt; and is hence a
&lt;em&gt;higher-order logic programming language&lt;/em&gt; (more on what that means later); I worked on it
with &lt;a href=&#34;http://adam.chlipala.net&#34;&gt;Adam Chlipala&lt;/a&gt; while I was a post-doc at MIT. Since then,
development has been on an on-and-off basis as a personal project while
at &lt;a href=&#34;http://www.originate.com&#34;&gt;Originate&lt;/a&gt;, but over the past six months or so I&amp;rsquo;ve been working quite
a bit on it.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;This post contains Makam code that you can run using the Play button on the bottom-right corner&lt;/strong&gt;; you
can also edit the final code block to try out your own examples (the second button will take you
there). You can also follow
the &lt;a href=&#34;https://github.com/astampoulis/makam#installation&#34;&gt;installation instructions&lt;/a&gt; for Makam and run
this post on your machine if
you
&lt;a href=&#34;https://astampoulis.github.io/blog/makam-tutorial-01.md&#34;&gt;download the source code for this post&lt;/a&gt; and
do &amp;ldquo;&lt;code&gt;makam makam-tutorial-01.md -&lt;/code&gt;&amp;rdquo;.&lt;/p&gt;

&lt;p&gt;In this series of posts, we will use Makam to prototype various parts of a toy programming
language. We will also talk through the current set of answers of the lambda-Prolog/Makam language
design, in terms of what the base constructs are, and what can be programmed using those.&lt;/p&gt;

&lt;p&gt;A caveat before we start is that many things are work-in-progress. Though the base language and
implementation are pretty well established at this point, Makam is still in a state of evolution and
refinement. Mostly, I am exploring what further tools are needed for doing language prototyping
effectively and implementing those for Makam, using Makam itself.&lt;/p&gt;

&lt;h1 id=&#34;expressing-the-main-constructs-of-our-language-abstract-syntax&#34;&gt;Expressing the main constructs of our language: Abstract syntax&lt;/h1&gt;

&lt;p&gt;Let&amp;rsquo;s start defining and implementing our toy language. First of all, we will need to decide what
our base constructs are. To keep things simple let&amp;rsquo;s start with this:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;String constants like &lt;code&gt;&amp;quot;foo&amp;quot;&lt;/code&gt;, &lt;code&gt;&amp;quot;bar&amp;quot;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Integer constants like &lt;code&gt;5&lt;/code&gt;, &lt;code&gt;42&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Boolean constants, namely &lt;code&gt;true&lt;/code&gt; and &lt;code&gt;false&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;An expression to add two integers or two strings together&lt;/li&gt;
&lt;li&gt;Array literal expressions, like &lt;code&gt;[40 + 2, &amp;quot;foo&amp;quot;]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Record literal expressions, like &lt;code&gt;{ foo: &amp;quot;bar&amp;quot; }&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Here is a more formal way where you might see this kind of definition of language constructs on paper:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;$$\begin{array}{llll}
e &amp;amp; \text{(expressions)} &amp;amp; ::= &amp;amp; s \; | \; n \; | \; b \; | \; e_1 + e_2 \; | \; [ e_1, \cdots, e_n ] \; | \; \\
                         &amp;amp; &amp;amp; &amp;amp;   \{ s_1: e_1, \cdots, s_n: e_n \} \\
s &amp;amp; \text{(string constants)} &amp;amp; ::= &amp;amp; \cdots \\
n &amp;amp; \text{(integer constants)} &amp;amp; ::= &amp;amp; \cdots \\
b &amp;amp; \text{(boolean constants)} &amp;amp; ::= &amp;amp; \text{true} \; | \; \text{false}
\end{array}$$&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;In this notation, &lt;em&gt;expressions&lt;/em&gt;, &lt;em&gt;string constants&lt;/em&gt;, &lt;em&gt;integer constants&lt;/em&gt; etc. are different &lt;strong&gt;sorts&lt;/strong&gt; —
the different &amp;ldquo;kinds of things&amp;rdquo; that might be involved in the terms of our language.  For example,
if we were encoding an imperative language that included statements and statement blocks, we would
have separate sorts for them, like:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;$$\begin{array}{llll}
st &amp;amp; \text{(statements)} &amp;amp; ::= &amp;amp; x = e; \; | \; \text{return} \; e;
    \; | \; \text{if} \; (e) \; \text{then} \; b_1 \; \text{else} \; b_2; \; | \; \\
&amp;amp; &amp;amp; &amp;amp; 
    \text{for} \; (\text{var} \; x \; \text{in} \; e) \; b;
    \; | \; \text{for} \; (\text{var} \; x \; \text{of} \; e) \; b; \; | \; \cdots \\
b &amp;amp; \text{(blocks)} &amp;amp; ::= &amp;amp; \{ \; st_1 \; \cdots \; st_n \; \}
\end{array}$$&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Each alternative given for a sort is a &lt;strong&gt;constructor&lt;/strong&gt;. When we read a constructor definition like
&amp;ldquo;$e_1 + e_2$&amp;rdquo; it means that it&amp;rsquo;s a constructor for expressions that is formed by two expressions. Similarly,
&amp;ldquo;$\text{if} \; (e) \; \text{then} \; b_1 \; \text{else} \; b_2;$&amp;rdquo; is formed by an expression
and two blocks. A constructor of the form &amp;ldquo;$[ e_1, \cdots, e_n ]$&amp;rdquo; means that it is formed through
a list of expressions. So the letters we give to sorts (like $e$, $s$) are a handy pun that
allows us to specify the constituent parts of each constructor concisely.&lt;/p&gt;

&lt;p&gt;Now this notation mixes a couple of things together: we are defining &lt;em&gt;what the constructors are&lt;/em&gt;
together with &lt;em&gt;what is the real syntax that we will use to write down those constructors&lt;/em&gt;.
However, we can separate those two aspects of the definition out. In terms of what the
language &lt;em&gt;is&lt;/em&gt;, the important part is &lt;em&gt;what the constructors are&lt;/em&gt;. The syntax that we use
for them is secondary: it is important in terms of actually writing down terms of the language
in a way that is human-readable, but we could have different syntaxes for the same exact language.&lt;/p&gt;

&lt;p&gt;Instead, we can separate those two concerns into two parts: one where we just give an explicit name
to each constructor and describe what its constituents are (how many are there and of what sorts) —
on paper, we could denote that with something like &amp;ldquo;$\text{add}(e_1, e_2)$&amp;ldquo;; and one where we
describe what the real syntactic form for the constructor is when we write out a program in the
language. When we talk about &lt;strong&gt;abstract syntax&lt;/strong&gt;, we refer to the first part; and &lt;strong&gt;concrete
syntax&lt;/strong&gt; is the latter one.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s now see how we would encode these in Makam.&lt;/p&gt;

&lt;p&gt;First of all, we define the &lt;em&gt;sorts&lt;/em&gt; that we need, which are referred to as &lt;em&gt;types&lt;/em&gt; in Makam.
For our simple language, we just need expressions:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-makam&#34;&gt;expr : type.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;There are built-in sorts for strings and integers in Makam; booleans and lists are already defined
in its standard library. Like in most functional languages, all elements of a list are of the same
type. So lists of expressions are a different type than, say, lists of strings: &lt;code&gt;list expr&lt;/code&gt;
vs. &lt;code&gt;list string&lt;/code&gt;. There&amp;rsquo;s two ways to write down a list; either in the form &lt;code&gt;[1, 2, 3]&lt;/code&gt;, or
in the form &lt;code&gt;1 :: 2 :: 3 ::  Nil&lt;/code&gt;, similar to other functional languages.&lt;/p&gt;

&lt;p&gt;With these in mind, we can define the constructors for expressions as follows. This corresponds
to the definition of the abstract syntax of our language, as mentioned above:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-makam&#34;&gt;stringconst : (S: string) -&amp;gt; expr.
intconst : (I: int) -&amp;gt; expr.
boolconst : (B: bool) -&amp;gt; expr.
add : (E1: expr) (E2: expr) -&amp;gt; expr.
array : (ES: list expr) -&amp;gt; expr.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So we first give the name of the constructor, like &lt;code&gt;add&lt;/code&gt;, the arguments it takes (that is, its
constituent parts), like &lt;code&gt;(E1: expr) (E2: expr)&lt;/code&gt;, and the resulting sort that it belongs to, like
&lt;code&gt;expr&lt;/code&gt;, following the arrow.  The names of the arguments, like &lt;code&gt;E1&lt;/code&gt; and &lt;code&gt;E2&lt;/code&gt;, are only given as
documentation. This helps sometimes to disambiguate between what each different argument is — for
example, we could define the &lt;code&gt;if&lt;/code&gt;-&lt;code&gt;then&lt;/code&gt;-&lt;code&gt;else&lt;/code&gt; statement as:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-makam-noeval&#34;&gt;ifthenelse :
  (Condition: expr) (Then: block) (Else: block) -&amp;gt; statement.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Terms built out from constructors like these correspond exactly to abstract syntax trees. For example,
the abstract syntax tree for the concrete syntax &lt;code&gt;5 + 3&lt;/code&gt; would be:&lt;/p&gt;

&lt;p&gt;&lt;center&gt;&lt;img src=&#34;https://astampoulis.github.io/blog/makam-tutorial-01-pic1.svg&#34; alt=&#34;Abstract syntax tree&#34; width=&#34;300&#34; /&gt;&lt;/center&gt;&lt;/p&gt;

&lt;p&gt;We would write this as &lt;code&gt;add (intconst 5) (intconst 3)&lt;/code&gt; in Makam.&lt;/p&gt;

&lt;p&gt;You might find something about the above definitions weird at first, coming from a language like
Haskell from ML. Typically in functional languages we define datatypes and give all of their
constructors as part of a single declaration. Here, however, we have defined new types and new
constructors for those types as separate statements. In Makam, this different style of definitions
allows us to define new constructors for an existing type at any point. This is a key departure of
Makam/lambda-Prolog from traditional functional languages; the next post will be mostly about this
feature and what it allows us to do. For the time being though, we can say that one case where this
feature is useful is developing a language in stages: for example, we can define a &amp;lsquo;base version&amp;rsquo; of
a language first, and then add some extra constructs later, in a separate place, without having to
change the base definition.&lt;/p&gt;

&lt;p&gt;We have left the constructor for records out. We can view a record as a list of fields, where each
field pairs together a key with a value:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-makam&#34;&gt;field : type.
record : (Fields: list field) -&amp;gt; expr.
mkfield : (Key: string) (Val: expr) -&amp;gt; field.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And that covers all the constructors we&amp;rsquo;ll define for the time being. Now let&amp;rsquo;s see how to actually
define &lt;em&gt;computations&lt;/em&gt; over these terms. Our example will be an interpreter for our language
that computes the value that an expression evaluates to.&lt;/p&gt;

&lt;h1 id=&#34;computation-in-logic-programming&#34;&gt;Computation in logic programming&lt;/h1&gt;

&lt;p&gt;We have to pause working on our toy language implementation for a bit to first explain a little bit
about how computation in Makam works.&lt;/p&gt;

&lt;p&gt;Say that instead of using Makam, we were using a functional language. One of the main operations
of functional languages is &lt;em&gt;pattern-matching&lt;/em&gt;: we try to match a term against a pattern; if
the match is successful, we proceed to take the corresponding branch.  Patterns are kind of like
&amp;ldquo;templates&amp;rdquo; for terms: some parts are explicitly specified, while others are allowed to be
arbitrary. Another way to say this, is that if terms are like trees, patterns are like &amp;ldquo;trees with
holes&amp;rdquo;:&lt;/p&gt;

&lt;p&gt;&lt;center&gt;&lt;img src=&#34;https://astampoulis.github.io/blog/makam-tutorial-01-pic2.svg&#34; alt=&#34;Pattern&#34; width=&#34;300&#34; /&gt;&lt;/center&gt;&lt;/p&gt;

&lt;p&gt;We give names to the holes, so as to be able to refer to them — these are the &lt;em&gt;pattern variables&lt;/em&gt;.
Pattern matching basically tries to find a way to fill in these holes in the pattern so that it
matches the term exactly.  So its result when it&amp;rsquo;s successful is an instantiation (or substitution)
for the pattern variables:&lt;/p&gt;

&lt;p&gt;&lt;center&gt;&lt;img src=&#34;https://astampoulis.github.io/blog/makam-tutorial-01-pic3.svg&#34; alt=&#34;Pattern&#34; width=&#34;550&#34; /&gt;&lt;/center&gt;&lt;/p&gt;

&lt;p&gt;Here&amp;rsquo;s an example of a query that performs pattern matching between a pattern and a term in
Makam. We will talk about what queries &lt;em&gt;are&lt;/em&gt; later on, but if you run this post right now using the Play button
on the bottom-right corner, you will see that an instantiation for the pattern variables &lt;code&gt;N&lt;/code&gt;, &lt;code&gt;X&lt;/code&gt; is found:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-makam&#34;&gt;pattern_match
  (add (intconst N) X)
  (add (intconst 5) (intconst 3)) ?
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-makam-hidden&#34;&gt;&amp;gt;&amp;gt; Yes:
&amp;gt;&amp;gt; N := 5,
&amp;gt;&amp;gt; X := intconst 3.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Logic programming instead allows terms to &lt;em&gt;include unknown parts&lt;/em&gt; in them and treats &lt;em&gt;unification&lt;/em&gt;
as one of the key operations.  This is the symmetric, more general, version of pattern matching:
instead of having a &amp;ldquo;pattern&amp;rdquo; with potentially unknown parts on the left, and a fully known &amp;ldquo;term&amp;rdquo;
on the right, we have two terms with potentially unknown parts in them, and we are trying to
reconcile them against each other. This process might force instantiations on either one of them,
making previously unknown parts known, or even on both of them (in different parts of them). Some
things might even remain unknown after the unification. To be able to refer to them, we give names
to the unknown parts — so an unknown part is a special kind of a variable, referred to as a
&lt;em&gt;unification variables&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;&lt;center&gt;&lt;img src=&#34;https://astampoulis.github.io/blog/makam-tutorial-01-pic4.svg&#34; alt=&#34;Pattern&#34; width=&#34;550&#34; /&gt;&lt;/center&gt;&lt;/p&gt;

&lt;p&gt;In Makam, unification variables are denoted with identifiers starting with
uppercase letters, whereas the identifiers of normal term constructors start with lowercase letters.
Here&amp;rsquo;s an example of a query that performs unification between two terms, corresponding to the example
above:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-makam&#34;&gt;unify (add (intconst N1) X2) (add X1 (intconst N2)) ?
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-makam-hidden&#34;&gt;&amp;gt;&amp;gt; Yes:
&amp;gt;&amp;gt; X1 := intconst N1,
&amp;gt;&amp;gt; X2 := intconst N2,
&amp;gt;&amp;gt; N1 := N1,
&amp;gt;&amp;gt; N2 := N2.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;(Note the color-coding on the side of codeblocks of this post: blue blocks are things that will be sent
to Makam, which become green after a successful run, and grey ones are skipped. Any results from the Makam
interpreter, or any errors, show up as annotations in each codeblock.)&lt;/p&gt;

&lt;p&gt;This choice has a wide-ranging implication on how computation in logic programming actually looks.
In a functional language, at the point where a function is applied, its inputs are fully known (or
at least fully knowable, in a call-by-need language), whereas outputs are fully unknown, to be
determined through evaluation of the function. In a logic programming language, there is no need to
explicitly separate inputs from outputs: both of them could only be partially known at the point
where a &amp;ldquo;function&amp;rdquo; is applied, and unification will reconcile the known and unknown parts.  So
instead of functions we talk about &lt;em&gt;predicates&lt;/em&gt;: these describe relations between terms, without
explicitly designating some of them as inputs and some as outputs. What is an input and what is an
output depends on the arguments that the predicates are called with. Here is an example of the
&lt;code&gt;append&lt;/code&gt; predicate for lists:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-makam&#34;&gt;append [1,2,3] [4,5,6] ZS ?
append [1,2,3] YS [1,2,3,4,5,6] ?
append XS [4,5,6] [1,2,3,4,5,6] ?
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So the &lt;code&gt;append XS YS ZS&lt;/code&gt; predicate takes three lists as arguments; the first two, &lt;code&gt;XS&lt;/code&gt;, &lt;code&gt;YS&lt;/code&gt;, are
the operands, and &lt;code&gt;ZS&lt;/code&gt;, the last one, is the result of the append. However, the predicate can be
used not only to find the result of appending a fully-known &lt;code&gt;YS&lt;/code&gt; to &lt;code&gt;XS&lt;/code&gt;, but also to discover the
value of &lt;code&gt;XS&lt;/code&gt; or &lt;code&gt;YS&lt;/code&gt; given the other operand and the result. Here is the type of &lt;code&gt;append&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-makam-noeval&#34;&gt;append : (XS: list int) (YS: list int) (ZS: list int) -&amp;gt; prop.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The name of the type &lt;code&gt;prop&lt;/code&gt; comes from &lt;em&gt;proposition&lt;/em&gt;: these are the statements that we can query
upon, and might be viewed as the logic programming equivalent of the &lt;em&gt;expressions&lt;/em&gt; of a functional
programming language. So a fully applied predicate like &lt;code&gt;append XS YS ZS&lt;/code&gt; is a proposition, and by
querying about it as we did above, we are asking the Makam interpreter to find an instantiation for
the unknown &lt;em&gt;unification variables&lt;/em&gt; that makes the proposition hold.&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;append&lt;/code&gt; queries above might be surprising at first, so let&amp;rsquo;s see how &lt;code&gt;append&lt;/code&gt; is implemented.
In logic programming, we implement a predicate by defining its &lt;em&gt;rules&lt;/em&gt;: basically, we define the cases for
which a certain proposition, like &lt;code&gt;append XS YS ZS&lt;/code&gt; holds. Each rule has a &lt;em&gt;goal&lt;/em&gt; and optional &lt;em&gt;premises&lt;/em&gt;,
written roughly as &lt;code&gt;goal :- premises&lt;/code&gt; (note the &amp;ldquo;&lt;code&gt;:-&lt;/code&gt;&amp;rdquo; which can be read as &lt;strong&gt;&amp;ldquo;when&amp;rdquo;&lt;/strong&gt;). The way
these rules are executed is like this: given the current query &lt;code&gt;Q&lt;/code&gt; that we are trying to solve, we
attempt to unify it with the goal of each rule; if unification is successful, we proceed to the
premises, treating them as subsequent queries that need to be satisfied.&lt;/p&gt;

&lt;p&gt;The rules that make up &lt;code&gt;append&lt;/code&gt; are these:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-makam-noeval&#34;&gt;append [] YS YS.
append (X :: XS) YS (X :: XSYS) :- append XS YS XSYS.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The first rule says: appending &lt;code&gt;YS&lt;/code&gt; to an empty list results in &lt;code&gt;YS&lt;/code&gt;. The second rule says:
appending &lt;code&gt;YS&lt;/code&gt; to a list that has &lt;code&gt;X&lt;/code&gt; as a head and &lt;code&gt;XS&lt;/code&gt; as tails results in a list with &lt;code&gt;X&lt;/code&gt;
as a head and &lt;code&gt;XSYS&lt;/code&gt; as a tail, &lt;strong&gt;when&lt;/strong&gt; appending &lt;code&gt;YS&lt;/code&gt; to &lt;code&gt;XS&lt;/code&gt; results in &lt;code&gt;XSYS&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;It&amp;rsquo;s a good exercise to try to convince yourself &lt;em&gt;why&lt;/em&gt; the queries we saw above actually work,
based on the small explanation I gave of how rules are executed. There really is not a lot of
magic going on!&lt;/p&gt;

&lt;p&gt;One might ask — why is it useful to have a language that relies on unification and relations instead
of functions? One example is that when implementing a type checking procedure for a language,
blurring the line between inputs and outputs allows us to get a type inferencing procedure
essentially for free. But that is getting too much ahead of ourselves; we will see more in later
posts.&lt;/p&gt;

&lt;p&gt;With this out of the way, it is time to try our hand at writing our first predicate over the
expressions we defined.&lt;/p&gt;

&lt;h1 id=&#34;writing-an-interpreter-for-our-language&#34;&gt;Writing an interpreter for our language&lt;/h1&gt;

&lt;p&gt;Let&amp;rsquo;s go back to implementing our toy language now. Here is the base declaration of a predicate that
relates an expression of our language with the value it will result in upon evaluation. We can use
this predicate as an interpreter, if we give it a complete expression and a fully unknown value as
arguments.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-makam&#34;&gt;eval : (E: expr) (V: expr) -&amp;gt; prop.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here&amp;rsquo;s how we would use this, to evaluate/interpret a small example program:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-makam&#34;&gt;eval (add (intconst 1) (intconst 2)) Value ?
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Of course, this query fails at this point, as we have not given any kind of implementation for the
&lt;code&gt;eval&lt;/code&gt; predicate. So let&amp;rsquo;s start with adding some rules to evaluate integer constants and integer
addition:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-makam&#34;&gt;eval (intconst I) (intconst I).
eval (add E1 E2) (intconst N) :-
  eval E1 (intconst N1),
  eval E2 (intconst N2),
  plus N1 N2 N.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;(Note the distinction between &lt;code&gt;add&lt;/code&gt; which is one of the constructors of expressions that we have
defined, and &lt;code&gt;plus&lt;/code&gt;, which is a built-in predicate for adding integers together.)&lt;/p&gt;

&lt;p&gt;The first rule says: integer constants evaluate to themselves (because they are already values).
The second one can be read as: the &lt;code&gt;add&lt;/code&gt; expression evaluates to an integer constant &lt;code&gt;N&lt;/code&gt;, &lt;em&gt;when&lt;/em&gt;
the two operands evaluate to the integer constants &lt;code&gt;N1&lt;/code&gt; and &lt;code&gt;N2&lt;/code&gt;, and we also have &lt;code&gt;N = N1 + N2&lt;/code&gt;.
With these two rules, the query from above should now work:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-makam&#34;&gt;eval (add (intconst 1) (intconst 2)) Value ?
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-makam-hidden&#34;&gt;&amp;gt;&amp;gt; Yes:
&amp;gt;&amp;gt; Value := intconst 3.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;(Note that in a functional language when defining a function by pattern-matching, we &lt;em&gt;have&lt;/em&gt; to give
its full definition. In logic programming, we can add new rules for a predicate at any point of our
program, similarly to how we can add new constructors at any point.)&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s also add the cases for boolean constants, string constants and appending strings together. For
the latter one, we can use the Makam builtin string predicate &lt;code&gt;string.append&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-makam&#34;&gt;eval (boolconst B) (boolconst B).
eval (stringconst S) (stringconst S).
eval (add E1 E2) (stringconst S) :-
  eval E1 (stringconst S1),
  eval E2 (stringconst S2),
  string.append S1 S2 S.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Let&amp;rsquo;s try a couple more queries:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-makam&#34;&gt;eval (add (stringconst &amp;quot;foo&amp;quot;) (stringconst &amp;quot;bar&amp;quot;)) V ?
eval (add (intconst 5) (stringconst &amp;quot;foo&amp;quot;)) V ?
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-makam-hidden&#34;&gt;eval (add (stringconst &amp;quot;foo&amp;quot;) (stringconst &amp;quot;bar&amp;quot;)) V ?
&amp;gt;&amp;gt; Yes:
&amp;gt;&amp;gt; V := stringconst &amp;quot;foobar&amp;quot;.

eval (add (intconst 5) (stringconst &amp;quot;foo&amp;quot;)) V ?
&amp;gt;&amp;gt; Impossible.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Of course, the last query fails, as it should: we have only defined rules to handle the case where
the operands to &lt;code&gt;add&lt;/code&gt; evaluate to the same type of constant. That could be a deliberate choice
depending on how we want evaluation in our language to behave.&lt;/p&gt;

&lt;p&gt;How about arrays? For an array like &lt;code&gt;[1 + 2, &amp;quot;foo&amp;quot; + &amp;quot;bar&amp;quot;]&lt;/code&gt;, every member of the array needs to
be evaluated. We can describe this using two rules:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-makam&#34;&gt;eval (array []) (array []).

eval (array (HeadExpr :: TailExprs))
     (array (HeadVal :: TailVals)) :-
  eval HeadExpr HeadVal, eval (array TailExprs) (array TailVals).
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Let&amp;rsquo;s try this out:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-makam&#34;&gt;eval (array [
       add (intconst 1) (intconst 2),
       add (stringconst &amp;quot;foo&amp;quot;) (stringconst &amp;quot;bar&amp;quot;)])
     Value ?
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-makam-hidden&#34;&gt;&amp;gt;&amp;gt; Yes:
&amp;gt;&amp;gt; Value := array [ intconst 3, stringconst &amp;quot;foobar&amp;quot; ].
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;(As an aside — we can do better than this. Remember when we said that Makam is a &lt;em&gt;higher-order&lt;/em&gt; logic
programming language? That means that we can define higher-order predicates — predicates that
take other predicates as arguments — similarly to how we can define higher-order functions
in a higher-order functional programming language. One example of such a predicate is &lt;code&gt;map&lt;/code&gt;
for lists, which is defined as follows in the Makam standard library:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-makam-noeval&#34;&gt;map Pred [] [].
map Pred (X :: XS) (Y :: YS) :- Pred X Y, map Pred XS YS.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The evaluation rule for arrays would then be:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-makam-noeval&#34;&gt;eval (array Exprs) (array Vals) :- map eval Exprs Vals.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;More on this on a later installment.)&lt;/p&gt;

&lt;p&gt;Evaluating records is a little more complicated. We need to evaluate the expressions contained
within them, so that &lt;code&gt;{ foo: 1 + 1, bar: 2 + 2 }&lt;/code&gt; evaluates to &lt;code&gt;{ foo: 2, bar: 4 }&lt;/code&gt;. However, we
also need to decide what to do about duplicate key entries, as in &lt;code&gt;{ foo: 1, foo: 2 }&lt;/code&gt;. For that, we
will follow the JavaScript semantics for objects: duplicate entries for the same key are allowed,
and the last occurrence of the same key is the one that gets picked — so the previous object
evaluates to &lt;code&gt;{ foo: 2 }&lt;/code&gt;. We won&amp;rsquo;t follow the JavaScript semantics when it comes to ordering the
fields: instead, we will maintain the order of that appears in the source.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s see how to implement this in Makam. Here&amp;rsquo;s a first attempt where we
do not handle duplicate keys properly:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-makam-noeval&#34;&gt;eval (record []) (record []).
eval (record (mkfield Key Expr :: Rest))
     (record (mkfield Key Value :: Rest&#39;)) :-
  eval Expr Value,
  eval (record Rest) (record Rest&#39;).
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To account for duplicate keys, we need to split this last rule into two: one for the last occurrence
of a key (where the key does not appear in subsequent fields) and one for any earlier
occurrences. In this second case, the field can safely be ignored, as the language we are encoding
does not have any side effects. To distinguish the two cases, we can use an auxiliary predicate
&lt;code&gt;contains_key&lt;/code&gt; (so a new &lt;code&gt;prop&lt;/code&gt;), that succeeds whenever a key exists within a list of fields:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-makam&#34;&gt;contains_key : (Fields: list field) (Key: string) -&amp;gt; prop.
contains_key (mkfield Key Expr :: Rest) Key.
contains_key (Field :: Rest) Key :-
  contains_key Rest Key.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And here&amp;rsquo;s the rules for evaluation:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-makam&#34;&gt;eval (record []) (record []).
eval (record (mkfield Key Expr :: Rest))
     (record Rest&#39;) :-
  contains_key Rest Key,
  eval (record Rest) (record Rest&#39;).
eval (record (mkfield Key Expr :: Rest))
     (record (mkfield Key Value :: Rest&#39;)) :-
  not(contains_key Rest Key),
  eval Expr Value, eval (record Rest) (record Rest&#39;).
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note the use of &lt;code&gt;not&lt;/code&gt; here: basically, we are saying that this last rule applies whenever
&lt;code&gt;contains_key Rest Key&lt;/code&gt; is not successful&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:1&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:1&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;.&lt;/p&gt;

&lt;p&gt;With these, the interpreter for our toy language is complete!&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-makam&#34;&gt;eval (record [
  mkfield &amp;quot;foo&amp;quot; (add (intconst 1) (intconst 1)),
  mkfield &amp;quot;bar&amp;quot; (array [ add (intconst 2) (intconst 2) ]),
  mkfield &amp;quot;foo&amp;quot; (add (intconst 4) (intconst 4))
]) V ?
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-makam-hidden&#34;&gt;&amp;gt;&amp;gt; Yes:
&amp;gt;&amp;gt; V := record [mkfield &amp;quot;bar&amp;quot; (array [intconst 4]), mkfield &amp;quot;foo&amp;quot; (intconst 8)].
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;defining-the-concrete-syntax-for-our-language&#34;&gt;Defining the concrete syntax for our language&lt;/h1&gt;

&lt;p&gt;One issue with our interpreter, which is quite evident in the query above, is that we have to use
abstract syntax for writing down the terms of our language — and that&amp;rsquo;s not always pleasant.
Abstract syntax is often quite long-winded and verbose, even for simple terms.  It would be
nice to be able to use concrete syntax instead, to write queries like:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-makam-noeval&#34;&gt;evalstring &amp;lt;&amp;lt; { &amp;quot;foo&amp;quot;: &amp;quot;a&amp;quot;, &amp;quot;foo&amp;quot;: [ &amp;quot;bar&amp;quot;, 40 + 2 ] } &amp;gt;&amp;gt; Y ?
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;(The syntax form &lt;code&gt;&amp;lt;&amp;lt; .. &amp;gt;&amp;gt;&lt;/code&gt; is alternative syntax for strings in Makam, so that we don&amp;rsquo;t have to
escape the quotes &lt;code&gt;&amp;quot;&lt;/code&gt; within it.)&lt;/p&gt;

&lt;p&gt;What we need is a parser, that converts a &lt;code&gt;string&lt;/code&gt; containing concrete syntax into the abstract
syntax terms that we have defined. So we need to define a predicate with the type:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-makam-noeval&#34;&gt;parse_expr : (Concrete: string) (Abstract: expr) -&amp;gt; prop.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Let&amp;rsquo;s ruminate on this: given a query on &lt;code&gt;parse_expr&lt;/code&gt;, what would happen if the second argument was a
fully-known abstract syntax tree, whereas the first argument was fully unknown? In that case, we would
be reconstructing the concrete syntax of an abstract syntax tree — namely, we would be using this
predicate as a pretty-printer for our terms.&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:2&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:2&#34;&gt;2&lt;/a&gt;&lt;/sup&gt; So maybe &lt;code&gt;parse_expr&lt;/code&gt; is not such a great name for our
predicate, since we could use it both as a parser and a pretty-printer of expressions.&lt;/p&gt;

&lt;p&gt;How about writing the predicate itself? Makam already has a &lt;code&gt;syntax&lt;/code&gt; library that can help us
implement syntax predicates like these by only giving a grammar for our language, similar to how
parser generators are used in other languages. I will give an example of how to use it for the language we have defined in this post, and will
just say that the parsing aspect of the library is based
on &lt;a href=&#34;https://pdos.csail.mit.edu/papers/parsing:popl04.pdf&#34;&gt;PEG parsing&lt;/a&gt;&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:3&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:3&#34;&gt;3&lt;/a&gt;&lt;/sup&gt; and I am using an
adaptation
of
&lt;a href=&#34;http://www.mathematik.uni-marburg.de/~rendel/rendel10invertible.pdf&#34;&gt;Invertible Syntax Descriptions&lt;/a&gt;&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:4&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:4&#34;&gt;4&lt;/a&gt;&lt;/sup&gt;
to the PEG setting so that the same grammar is used both for parsing and pretty printing.&lt;/p&gt;

&lt;p&gt;Before looking at the code, let me briefly explain the components that go into it. First, we
need to define &amp;ldquo;syntax constructors&amp;rdquo; which are akin to typed non-terminals in grammars: for example,
a syntax constructor with the type &lt;code&gt;syntax expr&lt;/code&gt; will be used as a handle that allows us to parse
and pretty-print terms of type &lt;code&gt;expr&lt;/code&gt;. Then, we need to give syntactic rules, which describe how to
parse/pretty-print each term constructor (like &lt;code&gt;stringconst&lt;/code&gt;, &lt;code&gt;array&lt;/code&gt;, etc.). Last, we need to generate
parsing/pretty-printing code for each toplevel syntax constructor; this is akin to running a parser
generator to get the parsing code for our grammar. This step, just as all the other steps, happens
within the same Makam program instead of requiring an external parser generator.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-makam-hidden&#34;&gt;%open syntax.
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-makam&#34;&gt;baseexpr, expr : syntax expr.
field : syntax field.

`(syntax_rules &amp;lt;&amp;lt;

  expr -&amp;gt;
    add         { &amp;lt;baseexpr&amp;gt; &amp;quot;+&amp;quot; &amp;lt;expr&amp;gt; }
  / baseexpr ;

  baseexpr -&amp;gt;
    stringconst { &amp;lt;makam.string_literal&amp;gt; }
  / intconst    { &amp;lt;makam.int_literal&amp;gt; }
  / array       { &amp;quot;[&amp;quot; &amp;lt;list_sep (token &amp;quot;,&amp;quot;) expr&amp;gt; &amp;quot;]&amp;quot; }
  / record      { &amp;quot;{&amp;quot; &amp;lt;list_sep (token &amp;quot;,&amp;quot;) field&amp;gt; &amp;quot;}&amp;quot; }
  / { &amp;quot;(&amp;quot; &amp;lt;expr&amp;gt; &amp;quot;)&amp;quot; } ;

  field -&amp;gt;
    mkfield     { &amp;lt;makam.ident&amp;gt; &amp;quot;:&amp;quot; &amp;lt;expr&amp;gt; }
  / mkfield     { &amp;lt;makam.string_literal&amp;gt; &amp;quot;:&amp;quot; &amp;lt;expr&amp;gt; }

&amp;gt;&amp;gt;).
`( syntax.def_toplevel_js expr ).
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Let&amp;rsquo;s try out parsing and pretty-printing. We will use the &lt;code&gt;syntax.run&lt;/code&gt; predicate, which does
either of these two depending on its arguments:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-makam&#34;&gt;syntax.run expr &amp;quot;{ foo: 1, bar: 2 + 2 }&amp;quot; Expr ?
syntax.run expr String (record [ mkfield &amp;quot;foo&amp;quot; (intconst 5) ]) ?
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-makam-hidden&#34;&gt;&amp;gt;&amp;gt; syntax.run expr &amp;quot;{ foo: 1, bar: 2 + 2 }&amp;quot; Expr ?
&amp;gt;&amp;gt; Yes:
&amp;gt;&amp;gt; Expr := record [ mkfield &amp;quot;foo&amp;quot; (intconst 1), mkfield &amp;quot;bar&amp;quot; (add (intconst 2) (intconst 2)) ].

&amp;gt;&amp;gt; syntax.run expr String (record [ mkfield &amp;quot;foo&amp;quot; (intconst 5) ]) ?
&amp;gt;&amp;gt; Yes:
&amp;gt;&amp;gt; String := &amp;quot;{ foo : 5 } &amp;quot;.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;OK, let&amp;rsquo;s unpack the code above a bit and explain what goes into it. The toplevel syntax constructor
is &lt;code&gt;expr&lt;/code&gt;, which we will use to parse and pretty-print expressions of our language. We also make use
of two additional auxiliary syntaxes, one for base expressions and one for fields. &lt;code&gt;expr&lt;/code&gt; represents
the higher-precedence part of expressions — right now, this just stands for infix addition — while
base expressions are the lower-precedence ones, which is everything else. The syntax library does
not presently include any explicit support for describing precedence, and that&amp;rsquo;s why we had to split
into top-level and base expressions manually. Each syntax rule specifies the constructor that it is
parsing/pretty-printing, along with any number of tokens and other syntax expressions that are
needed. Each expression within the angle brackets needs to correspond to the type of each argument
of the constructor: for example, in the first rule for the &lt;code&gt;mkfield&lt;/code&gt; constructor, which requires a
string followed by an expression, &lt;code&gt;makam.ident&lt;/code&gt; is a syntax constructor of type &lt;code&gt;syntax string&lt;/code&gt; and
&lt;code&gt;expr&lt;/code&gt; is of type &lt;code&gt;syntax expr&lt;/code&gt;.  The &lt;code&gt;list_sep&lt;/code&gt; incantation for &lt;code&gt;array&lt;/code&gt; and &lt;code&gt;record&lt;/code&gt; is used to
parse/pretty-print a list with the specified separator, which here is the &lt;code&gt;&amp;quot;,&amp;quot;&lt;/code&gt; token.&lt;/p&gt;

&lt;p&gt;One thing to note about the workings of these rules is that contrary to context-free grammars, the rules
here are applied in order and the choice is deterministic: given two rules like &lt;code&gt;A / B&lt;/code&gt;, we attempt to
parse/pretty-print using &lt;code&gt;A&lt;/code&gt;, and only if that fails &lt;code&gt;B&lt;/code&gt; is attempted. This has implications both for
parsing and pretty-printing: for example, if we switch the order of rules for &lt;code&gt;expr&lt;/code&gt;, we will never get
to the rule for &lt;code&gt;add&lt;/code&gt; when parsing, as &lt;code&gt;baseexpr&lt;/code&gt; is already parseable on its own, and that&amp;rsquo;s the first
prerequisite for &lt;code&gt;add&lt;/code&gt;. For pretty-printing, the order of rules means that a record will be
printed as &lt;code&gt;{ foo: ... }&lt;/code&gt; instead of &lt;code&gt;{ &amp;quot;foo&amp;quot;: ... }&lt;/code&gt; for keys that are identifiers; the string notation
will be used otherwise. Another note is that left recursion is not permitted, hence we could
not have a rule for &lt;code&gt;add&lt;/code&gt; like &lt;code&gt;&amp;lt;expr&amp;gt; &amp;quot;+&amp;quot; &amp;lt;expr&amp;gt;&lt;/code&gt; but need to break the recursion through &lt;code&gt;baseexpr&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Last, one small note for the syntax of Makam itself and how these definitions actually work: the
`&lt;code&gt;(&lt;/code&gt; notation stands for a call to a staging predicate: that is, a predicate that generates further
Makam code that is &amp;ldquo;inserted&amp;rdquo; in place. Here, &lt;code&gt;syntax_rules&lt;/code&gt; transforms these grammar rules (given
as a plain string with the notation &lt;code&gt;&amp;lt;&amp;lt; .. &amp;gt;&amp;gt;&lt;/code&gt;) into normal Makam rules that define parsing and
pretty-printing; whereas &lt;code&gt;syntax.def_toplevel_js&lt;/code&gt; generates some JavaScript code that is then inserted
into a normal Makam predicate that will be used for parsing.&lt;/p&gt;

&lt;p&gt;With &lt;code&gt;syntax.run expr&lt;/code&gt; defined, we can now define a predicate that is more akin
to the input-output portion of a REPL for our language, that takes an expression as
a concrete string as input, evaluates it and returns the result as a string again:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-makam&#34;&gt;evalstring : (ExprStr: string) (ValueStr: string) -&amp;gt; prop.
evalstring ExprStr ValueStr :-
  syntax.run expr ExprStr Expr,
  eval Expr Value,
  syntax.run expr ValueStr Value.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So what we do is that we first parse the concrete string; evaluate the expression
to a value; and pretty-print the resulting value into concrete syntax.&lt;/p&gt;

&lt;p&gt;We can now issue queries to try out our whole implementation so far. Note that
this query block is editable, so you can try your own queries as well:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-makam-input&#34;&gt;evalstring &amp;lt;&amp;lt; { &amp;quot;foo&amp;quot;: &amp;quot;a&amp;quot;, &amp;quot;foo&amp;quot;: [ &amp;quot;bar&amp;quot;, 40 + 2 ] } &amp;gt;&amp;gt; X ?
evalstring &amp;lt;&amp;lt; [ 1 + (12 + 12) ] &amp;gt;&amp;gt; X ?
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-makam-hidden&#34;&gt;&amp;gt;&amp;gt; evalstring &amp;lt;&amp;lt; { &amp;quot;foo&amp;quot;: &amp;quot;a&amp;quot;, &amp;quot;foo&amp;quot;: [ &amp;quot;bar&amp;quot;, 40 + 2 ] } &amp;gt;&amp;gt; X ?
&amp;gt;&amp;gt; Yes:
&amp;gt;&amp;gt; X := &amp;quot;{ foo : [ \&amp;quot;bar\&amp;quot; , 42 ] } &amp;quot;.

&amp;gt;&amp;gt; evalstring &amp;lt;&amp;lt; [ 1 + (12 + 12) ] &amp;gt;&amp;gt; X ?
&amp;gt;&amp;gt; Yes:
&amp;gt;&amp;gt; X := &amp;quot;[ 25 ] &amp;quot;.
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;conclusion&#34;&gt;Conclusion&lt;/h1&gt;

&lt;p&gt;We did cover quite a bit of stuff here: concrete and abstract syntax, the very basics of computation
in logic programming, and writing an interpreter for a very simple language. Next time we will cover
how to encode more complicated constructs, like functions, how to implement a type checker for our
language in Makam, and more on the basics of higher-order logic programming.&lt;/p&gt;
&lt;div class=&#34;footnotes&#34;&gt;

&lt;hr /&gt;

&lt;ol&gt;
&lt;li id=&#34;fn:1&#34;&gt;Negation in logic programming languages is a big topic, mostly because it breaks many of the invariants that hold about the language otherwise. For example: adding a new rule only makes more queries succeed, instead of making queries fail when they were previously succeeding; this does not hold in the presence of negation.
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:1&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:2&#34;&gt;The reality is more complicated of course — using the same predicate for both kinds of queries is not always possible for free, or will not always terminate. In a later post, we will explore this more in-depth.
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:2&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:3&#34;&gt;Bryan Ford. 2004. &lt;em&gt;Parsing expression grammars: a recognition-based syntactic foundation&lt;/em&gt;. In Proceedings of the 31st ACM SIGPLAN-SIGACT symposium on Principles of programming languages (POPL &amp;lsquo;04). ACM, New York, NY, USA, 111-122. DOI: &lt;a href=&#34;http://dx.doi.org/10.1145/964001.964011&#34;&gt;http://dx.doi.org/10.1145/964001.964011&lt;/a&gt;
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:3&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:4&#34;&gt;Tillmann Rendel and Klaus Ostermann. 2010. &lt;em&gt;Invertible syntax descriptions: unifying parsing and pretty printing&lt;/em&gt;. In Proceedings of the third ACM Haskell symposium on Haskell (Haskell &amp;lsquo;10). ACM, New York, NY, USA, 1-12. DOI: &lt;a href=&#34;https://doi.org/10.1145/1863523.1863525&#34;&gt;https://doi.org/10.1145/1863523.1863525&lt;/a&gt;
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:4&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
</description>
    </item>
    
    
    
    <item>
      <title>Literate Makam web pages and other recent news</title>
      <link>https://astampoulis.github.io/blog/makam-webui-etc/</link>
      <pubDate>Sun, 04 Feb 2018 11:27:37 -0500</pubDate>
      <author>antonis DOT stampoulis AT gmail DOT com (Antonis Stampoulis)</author>
      <guid>https://astampoulis.github.io/blog/makam-webui-etc/</guid>
      <description>&lt;p&gt;I have been working a lot on Makam in the past few months, the
metalanguage based on λProlog that I started implementing at MIT
working with &lt;a href=&#34;http://adam.chlipala.net&#34;&gt;Adam Chlipala&lt;/a&gt;.  The latest
feature I have been working on is a Web interface for Makam, meant to
be used for literate posts that have Makam code alongside the
text. The code is ran through a AWS Lambda Makam webservice. This is
the first such literate post &amp;ndash; so go ahead and evaluate the code of
this web page, or even try editing the final queries before
evaluating, using the two buttons on the bottom-right of the page!&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;p&gt;It goes without saying what the first query utilizing this interface
should be:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-makam-hidden&#34;&gt;post: testsuite. %testsuite post.
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-makam&#34;&gt;print_string &amp;quot;Hello world!\n&amp;quot; ?
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-makam-hidden&#34;&gt;&amp;gt;&amp;gt; Yes.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &amp;ldquo;Yes.&amp;rdquo; part you might notice in the result of this query means
that a solution was found. Typically, Makam queries will have
uninstantiated metavariables (that start with a capital letter), and
the point of executing them would be to find valid solutions for those
variables. More on these below.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-makam&#34;&gt;string.concat [&amp;quot;Hello&amp;quot;, &amp;quot; &amp;quot;, X, &amp;quot;!&amp;quot;] &amp;quot;Hello world!&amp;quot; ?
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-makam-hidden&#34;&gt;&amp;gt;&amp;gt; Yes:
&amp;gt;&amp;gt; X := &amp;quot;world&amp;quot;.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now that this interface is ready, I am planning to start a number of
tutorials on Makam and on language implementation. I also have a few
experimental ideas that I want to implement, where I would appreciate
some feedback, but that is a matter for a later time.  In any
case, &lt;a href=&#34;mailto:antonis DOT stampoulis AT gmail DOT com&#34;&gt;drop me a line&lt;/a&gt; with your
thoughts if you are reading this!&lt;/p&gt;

&lt;p&gt;Makam is meant to be used as a PL prototyping tool to explore research
ideas, and also as tool for encoding and understanding existing
languages and advanced type systems. It aims to be more of a very
expressive core language that can be used to define languages and
transformations between languages in a concise way, even when those
are quite involved.  In that sense, it does not aim to be a language
workbench that allows you to define specific aspects of your language
using different domain specific languages (e.g. parsing, name
resolution, typing, etc.), and gives you a full-blown IDE experience
as a result (for example, in the style
of &lt;a href=&#34;http://www.metaborg.org/en/latest/&#34;&gt;Spoofax&lt;/a&gt;). However, a lot of
the DSLs and tools that would comprise a language workbench in that
style can be implemented within Makam itself.&lt;/p&gt;

&lt;p&gt;One such DSL that I have defined lately is a bidirectional syntax
language. It can be used to define a parser and a pretty-printer for
the language you are implementing, through a single set of rules
(hence the &amp;lsquo;bidirectionality&amp;rsquo; in the name refers to viewing parsers
and pretty-printers as inverses of each other). The pretty-printing
part is quite basic at this point, but the parsing part is at a
relatively good state: it is based on PEG parser combinators, and it
generates parsing code in JavaScript that runs in Node.js under the
hood. This is done because Makam is interpreted and quite slow to
evaluate, so running the parsers in Node is a huge performance
boost. Of course, the parser generation, which transforms terms of the
PEG combinator language to JavaScript code, is implemented in Makam.&lt;/p&gt;

&lt;p&gt;Other things that I have been working on recently is a concrete
binding library, to convert between abstract syntax with concrete
names and abstract binding syntax utilizing HOAS; a testing framework;
and various additions to the standard library.  There&amp;rsquo;s now an &lt;code&gt;npm&lt;/code&gt;
package for Makam too with precompiled binaries for Linux and MacOS X,
if you want to execute Makam locally and do not already have OCaml
installed. With these, I felt like a version bump was in order, so
this also marks the release of Makam 0.7.0.&lt;/p&gt;

&lt;p&gt;As a small example of the syntax DSL, let&amp;rsquo;s implement a simple calculator
language and its syntax description. I will not go into full details, so
stay tuned for a more in-depth introductory post along the same
lines. First, we will define the terms of our language&amp;ndash; let&amp;rsquo;s say we
have integer constants, integer addition, &lt;code&gt;let&lt;/code&gt; expressions and variables.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-makam&#34;&gt;term : type.

intconst : int -&amp;gt; term.
add : term -&amp;gt; term -&amp;gt; term.
let : string -&amp;gt; term -&amp;gt; term -&amp;gt; term.
var : string -&amp;gt; term.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now let&amp;rsquo;s define the syntax for these. We split the syntax into
two precedence levels, and then give a syntax rule for each
term constructor. The angle brackets means that the result of
a parsing expression gets applied to the given term constructor &amp;ndash;
so each rule needs to apply the right kind of arguments in sequence.
Quoted strings stand for tokens.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-makam&#34;&gt;term, baseterm : syntax term.

`( syntax_rules {{

term -&amp;gt;
  add { &amp;lt;baseterm&amp;gt; &amp;quot;+&amp;quot; &amp;lt;term&amp;gt; }
/ let { &amp;quot;let&amp;quot; &amp;lt;makam.ident&amp;gt; &amp;quot;=&amp;quot; &amp;lt;term&amp;gt; &amp;quot;in&amp;quot; &amp;lt;term&amp;gt; }
/ baseterm
;

baseterm -&amp;gt;
  intconst { &amp;lt;makam.int_literal&amp;gt; }
/ var { &amp;lt;makam.ident&amp;gt; }
/ { &amp;quot;(&amp;quot; &amp;lt;term&amp;gt; &amp;quot;)&amp;quot; }

}}).

`( syntax.def_toplevel_js term ).
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The two statements starting with the `&lt;code&gt;(&lt;/code&gt; symbol are staged,
meaning that they are Makam programs that compute Makam
programs which are then evaluated in place. The former one
translates the surface-level syntax for syntax rules to
actual Makam rules; and the latter one generates a top-level
parser in JavaScript for the &lt;code&gt;term&lt;/code&gt;. The double-bracket
notation stands for multi-line strings, which is useful
when writing code of a different language.&lt;/p&gt;

&lt;p&gt;With these, we can issue parsing queries. For example:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-makam&#34;&gt;syntax.parse_opt term {{ let a = 21 in a + a }} X ?
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-makam-hidden&#34;&gt;&amp;gt;&amp;gt; Yes:
&amp;gt;&amp;gt; X := let &amp;quot;a&amp;quot; (intconst 21) (add (var &amp;quot;a&amp;quot;) (var &amp;quot;a&amp;quot;)).
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Let&amp;rsquo;s also define an evaluator for this language that returns the
result of an expression. This will be a predicate that relates a term
of the language to its integer value:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-makam&#34;&gt;eval : term -&amp;gt; int -&amp;gt; prop.

eval (intconst N) N.
eval (add E1 E2) N :-
  eval E1 N1, eval E2 N2,
  plus N1 N2 N.
eval (let VAR DEF BODY) N :-
  eval DEF N_DEF,
  (eval (var VAR) N_DEF -&amp;gt; eval BODY N).
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We can also define a version of the &lt;code&gt;eval&lt;/code&gt; predicate that accepts a
string as input, and parses the string before evaluating. Makam has
type-based overloading for constants, so types are used to
disambiguate between the two &lt;code&gt;eval&lt;/code&gt; predicates:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-makam&#34;&gt;eval : string -&amp;gt; int -&amp;gt; prop.
eval String Result :-
  syntax.parse_opt term String Term,
  eval Term Result.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Our simple calculator is ready! Here&amp;rsquo;s an example query:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-makam-hidden&#34;&gt;&amp;gt;&amp;gt; eval {{ let a = 21 in a + a }} X ?
&amp;gt;&amp;gt; Yes:
&amp;gt;&amp;gt; X := 42.
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-makam-input&#34;&gt;eval {{ let a = 21 in a + a }} X ?
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Using the Makam web interface, you can edit the query above &amp;ndash; the
Edit button on the bottom-right takes you directly to it &amp;ndash; and re-run
Makam to see the result with the Play button. (For the time being,
only the query is editable, mostly to limit the AWS Lambda execution
times; in the future, the rest of the Makam code blocks in a post
might be editable as well if that proves useful.)&lt;/p&gt;

&lt;p&gt;That&amp;rsquo;s it for the time being! More introductory tutorial posts should
be coming up soon!&lt;/p&gt;</description>
    </item>
    
    
    
    <item>
      <title>Welcome!</title>
      <link>https://astampoulis.github.io/blog/welcome/</link>
      <pubDate>Tue, 08 Sep 2015 13:57:59 -0400</pubDate>
      <author>antonis DOT stampoulis AT gmail DOT com (Antonis Stampoulis)</author>
      <guid>https://astampoulis.github.io/blog/welcome/</guid>
      <description>&lt;p&gt;I&amp;rsquo;m starting this blog as a way to post tutorial series on Makam, plus random thoughts.
I&amp;rsquo;m thinking of one series for programmers who want to learn more
about programming language theory, type systems, formal semantics, etc.; and another
one for programming language researchers who would like to use Makam to experiment
with new type system ideas.&lt;/p&gt;
</description>
    </item>
    
    
    
    
    
    
    
    
    
    
    
    
  </channel>
</rss>
