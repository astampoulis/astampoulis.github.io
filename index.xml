<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Blog posts from Antonis Stampoulis</title>
    <link>https://astampoulis.github.io/</link>
    <description>Recent posts on Antonis Stampoulis</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <managingEditor>antonis DOT stampoulis AT gmail DOT com (Antonis Stampoulis)</managingEditor>
    <webMaster>antonis DOT stampoulis AT gmail DOT com (Antonis Stampoulis)</webMaster>
    <lastBuildDate>Mon, 19 Mar 2018 18:16:01 -0400</lastBuildDate>
    <atom:link href="/" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Makam Tutorial 1: Prototyping a toy language and its interpreter</title>
      <link>https://astampoulis.github.io/blog/makam-tutorial-01/</link>
      <pubDate>Mon, 19 Mar 2018 18:16:01 -0400</pubDate>
      <author>antonis DOT stampoulis AT gmail DOT com (Antonis Stampoulis)</author>
      <guid>https://astampoulis.github.io/blog/makam-tutorial-01/</guid>
      <description>&lt;p&gt;&lt;em&gt;In this post, we&amp;rsquo;ll implement a toy interpreter for a small functional language. We will use Makam,
which is a language that helps in the &amp;lsquo;initial spiking phase&amp;rsquo; of designing a new language, allowing
for a tight feedback loop and for iterating quickly.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-makam-hidden&#34;&gt;tests : testsuite. %testsuite tests.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Some time ago I was designing and implementing a language: there was a class of programs that were
hard to write and I wanted better ways to express them.&lt;/p&gt;

&lt;p&gt;There were a lot of decisions to make. For starters, &lt;em&gt;what should the constructs of the language
be&lt;/em&gt;?  How do these constructs enable writing the example programs that I had in mind? Which
constructs should be the &amp;ldquo;core&amp;rdquo; ones of the language, and which ones should be defined in terms of
them?&lt;/p&gt;

&lt;p&gt;What does it mean to use the language? How do you write programs in it &amp;ndash; what&amp;rsquo;s the syntax like,
what information can one get about their programs (and how much of it can be inferred)?  What do the
constructs of the language mean &amp;ndash; how do you compute with them, how do they relate to the
constructs in existing languages?&lt;/p&gt;

&lt;p&gt;Coming up with answers to these questions is an iterative process: I would start with some answers,
try to write example programs, see what works and what does not, and adapt accordingly. Implementing
the language was quite crucial to this process: actually using the language revealed patterns
that were important but that I wouldn&amp;rsquo;t have found otherwise &amp;ndash; so that informed how to refine the
language further and what constructs to add.&lt;/p&gt;

&lt;p&gt;Still, implementing a language takes a long time, which hinders this experimentation and refinement
process. There is a long &amp;ldquo;feedback&amp;rdquo; loop involved between having a new language design idea and
having a working (even toy-ish) implementation of it.&lt;/p&gt;

&lt;p&gt;This is why I started working on the design and implementation of &lt;strong&gt;Makam&lt;/strong&gt;, which is a
&lt;strong&gt;metalanguage&lt;/strong&gt;: a language to help with designing and implementing (prototypes of) new
languages. It aims to minimize the feedback loop involved when designing a language, allowing
you to iterate and validate your language ideas quickly.&lt;/p&gt;

&lt;p&gt;Makam is a dialect of &lt;a href=&#34;http://www.lix.polytechnique.fr/~dale/lProlog/&#34;&gt;λProlog&lt;/a&gt; and is hence a
&lt;em&gt;higher-order logic programming language&lt;/em&gt; (more on what that means later); I worked on it
with &lt;a href=&#34;http://adam.chlipala.net&#34;&gt;Adam Chlipala&lt;/a&gt; while I was a post-doc at MIT. Since then,
development has been on an on-and-off basis as a personal project while
at &lt;a href=&#34;http://www.originate.com&#34;&gt;Originate&lt;/a&gt;, but over the past six months or so I&amp;rsquo;ve been working quite
a bit on it.&lt;/p&gt;

&lt;p&gt;In this series of posts, we will use Makam to prototype various parts of a toy programming
language. We will also talk through the current set of answers of the λProlog/Makam language design,
in terms of what the base constructs are, and what can be programmed using those.&lt;/p&gt;

&lt;p&gt;A caveat before we start is that many things are work-in-progress. Though the base language and
implementation is pretty well established at this point, Makam is still in a state of evolution and
refinement. Mostly, I am exploring what further tools are needed for doing language prototyping
effectively and implementing those for Makam, using Makam itself.&lt;/p&gt;

&lt;p&gt;So, welcome to the world of Makam. There are various levels of meta at play, some things are a bit
of a mess, but there are some nice things going on.&lt;/p&gt;

&lt;h1 id=&#34;expressing-the-main-constructs-of-our-language-abstract-syntax&#34;&gt;Expressing the main constructs of our language: Abstract syntax&lt;/h1&gt;

&lt;p&gt;Let&amp;rsquo;s start defining and implementing our toy language. First of all, we will need to decide what
our base constructs are. To keep things simple let&amp;rsquo;s start with this:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;String constants like &lt;code&gt;&amp;quot;foo&amp;quot;&lt;/code&gt;, &lt;code&gt;&amp;quot;bar&amp;quot;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Integer constants like &lt;code&gt;5&lt;/code&gt;, &lt;code&gt;42&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Boolean constants, namely &lt;code&gt;true&lt;/code&gt; and &lt;code&gt;false&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;An expression to add two integers or two strings together&lt;/li&gt;
&lt;li&gt;Array literal expressions, like &lt;code&gt;[40 + 2, &amp;quot;foo&amp;quot;]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Record literal expressions, like &lt;code&gt;{ foo: &amp;quot;bar&amp;quot; }&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Here is a more formal way where you might see this kind of definition of language constructs on paper:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;$$\begin{array}{llll}
e &amp;amp; \text{(expressions)} &amp;amp; ::= &amp;amp; s \; | \; n \; | \; b \; | \; e_1 + e_2 \; | \; [ e_1, \cdots, e_n ] \; | \; \\
                         &amp;amp; &amp;amp; &amp;amp;   \{ s_1: e_1, \cdots, s_n: e_n \} \\
s &amp;amp; \text{(string constants)} &amp;amp; ::= &amp;amp; \cdots \\
n &amp;amp; \text{(integer constants)} &amp;amp; ::= &amp;amp; \cdots \\
b &amp;amp; \text{(boolean constants)} &amp;amp; ::= &amp;amp; \text{true} \; | \; \text{false}
\end{array}$$&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;In this notation, &lt;em&gt;expressions&lt;/em&gt;, &lt;em&gt;string constants&lt;/em&gt;, &lt;em&gt;integer constants&lt;/em&gt; etc. are different &lt;strong&gt;sorts&lt;/strong&gt; &amp;ndash;
the different &amp;ldquo;kinds of things&amp;rdquo; that might be involved in the terms of our language.  For example,
if we were encoding an imperative language that included statements and statement blocks, we would
have separate sorts for them, like:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;$$\begin{array}{llll}
st &amp;amp; \text{(statements)} &amp;amp; ::= &amp;amp; x = e; \; | \; \text{return} \; e; \; | \;
    \; | \; \text{if} \; (e) \; \text{then} \; b_1 \; \text{else} \; b_2; \; | \; \\
&amp;amp; &amp;amp; &amp;amp; 
    \text{for} \; (\text{const} \; x \; \text{in} \; e) \; b; \; | \;
    \; | \; \text{for} \; (\text{const} \; x \; \text{of} \; e) \; b; \; | \; \cdots \\
b &amp;amp; \text{(blocks)} &amp;amp; ::= &amp;amp; \{ \; st_1 \; \cdots \; st_n \; \}
\end{array}$$&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Each alternative given for a sort is a &lt;strong&gt;constructor&lt;/strong&gt;. When we read a constructor definition like
&amp;ldquo;$e_1 + e_2$&amp;rdquo; it means that it&amp;rsquo;s a constructor for expressions that is formed by two expressions. Similarly,
&amp;ldquo;$\text{if} \; (e) \; \text{then} \; b_1 \; \text{else} \; b_2;$&amp;rdquo; is formed by an expression
and two blocks. A constructor of the form &amp;ldquo;$[ e_1, \cdots, e_n ]$&amp;rdquo; means that it is formed through
a list of expressions. So the letters we give to sorts (like $e$, $s$) are a handy pun that
allows us to specify the constituent parts of each constructor concisely.&lt;/p&gt;

&lt;p&gt;Now this notation mixes a couple of things together: we are defining &lt;em&gt;what the constructors are&lt;/em&gt;
together with &lt;em&gt;what is the real syntax that we will use to write down those constructors&lt;/em&gt;.
However, we can separate those two aspects of the definition out. In terms of what the
language &lt;em&gt;is&lt;/em&gt;, the important part is &lt;em&gt;what the constructors are&lt;/em&gt;. The syntax that we use
for them is secondary: it is important in terms of actually writing down terms of the language
in a way that is human-readable, but we could have different syntaxes for the same exact language.&lt;/p&gt;

&lt;p&gt;Instead, we can separate those two concerns into two parts: one where we just give an explicit name
to each constructor and describe what its constituents are (how many are there and of what sorts) &amp;ndash;
on paper, we could denote that with something like &amp;ldquo;$\text{add}(e_1, e_2)$&amp;ldquo;; and one where we
describe what the real syntactic form for the constructor is when we write out a program in the
language. When we talk about &lt;strong&gt;abstract syntax&lt;/strong&gt;, we refer to the first part; and &lt;strong&gt;concrete
syntax&lt;/strong&gt; is the latter one.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s now see how we would encode these in Makam.&lt;/p&gt;

&lt;p&gt;First of all, we define the &lt;em&gt;sorts&lt;/em&gt; that we need, which are referred to as &lt;em&gt;types&lt;/em&gt; in Makam.
For our simple language, we just need expressions:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-makam&#34;&gt;expr : type.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;There are built-in sorts for strings and integers in Makam; booleans and lists are already defined
in its standard library. Like in most functional languages, all elements of a list are of the same
type, so lists of expressions are a different type than, say, lists of strings.&lt;/p&gt;

&lt;p&gt;We can now define the constructors for expressions as follows:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-makam&#34;&gt;stringconst : (S: string) -&amp;gt; expr.
intconst : (I: int) -&amp;gt; expr.
boolconst : (B: bool) -&amp;gt; expr.
add : (E1: expr) (E2: expr) -&amp;gt; expr.
array : (ES: list expr) -&amp;gt; expr.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So we first give the name of the constructor, like &lt;code&gt;add&lt;/code&gt;, the arguments it takes (that is, its
constituent parts), like &lt;code&gt;(E1: expr) (E2: expr)&lt;/code&gt;, and the resulting sort that it belongs to, like
&lt;code&gt;expr&lt;/code&gt;, following the arrow.  The names of the arguments, like &lt;code&gt;E1&lt;/code&gt; and &lt;code&gt;E2&lt;/code&gt;, are only given as
documentation. This helps sometimes to disambiguate between what each different argument is &amp;ndash; for
example, we could define the &lt;code&gt;if&lt;/code&gt;-&lt;code&gt;then&lt;/code&gt;-&lt;code&gt;else&lt;/code&gt; statement as:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-makam-noeval&#34;&gt;ifthenelse :
  (Condition: expr) (Then: block) (Else: block) -&amp;gt; statement.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Terms built out from constructors like these correspond exactly to abstract syntax trees. For example,
the abstract syntax tree for the concrete syntax &lt;code&gt;5 + 3&lt;/code&gt; would be:&lt;/p&gt;

&lt;p&gt;&lt;center&gt;&lt;img src=&#34;https://astampoulis.github.io/blog/makam-tutorial-01-pic1.svg&#34; alt=&#34;Abstract syntax tree&#34; width=&#34;300&#34; /&gt;&lt;/center&gt;&lt;/p&gt;

&lt;p&gt;We would write this as &lt;code&gt;add (intconst 5) (intconst 3)&lt;/code&gt; in Makam.&lt;/p&gt;

&lt;p&gt;One thing that might be weird at first looking at the definitions above for somebody coming from a
language like Haskell or ML is that defining a new type and definining a new constructor are
separate statements. Typically in functional languages we define datatypes and give all of their
constructors as part of a single declaration. In Makam, this different style of declarations stems
from the fact that we can define new constructors for an existing type at any point.  That&amp;rsquo;s quite
useful for experimentation &amp;ndash; we can define a &amp;lsquo;base version&amp;rsquo; of a language first, and then try
adding new constructs later, in a separate place, without changing the base definition.&lt;/p&gt;

&lt;p&gt;For completeness, let&amp;rsquo;s look at the definition of booleans and lists:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-makam-noeval&#34;&gt;bool : type.
true : bool.
false : bool.

list : (A: type) -&amp;gt; type.
nil : list A.
cons : (Head: A) (Tail: list A) -&amp;gt; list A.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Lists are type constructors: that is, for each type &lt;code&gt;A&lt;/code&gt;, &lt;code&gt;list A&lt;/code&gt; is a type. There is syntactic
sugar for lists of the form &lt;code&gt;[1, 2, 3]&lt;/code&gt; or even &lt;code&gt;1 :: 2 :: 3 :: []&lt;/code&gt;. These declarations show what
the constructor notation is like when a constructor needs no arguments, as is the case for &lt;code&gt;true&lt;/code&gt;
and &lt;code&gt;false&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;We have left the constructor for records out. We can view records as a list of fields, where each
field pairs together a key with a value:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-makam&#34;&gt;field : type.
record : (Fields: list field) -&amp;gt; expr.
mkfield : (Key: string) (Val: expr) -&amp;gt; field.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And that covers all the constructors we&amp;rsquo;ll define for the time being. Now let&amp;rsquo;s see how to actually
define &lt;em&gt;computations&lt;/em&gt; over these terms. Our example will be an interpreter for our language,
that computes the value that an expression evaluates to.&lt;/p&gt;

&lt;h1 id=&#34;computation-in-logic-programming&#34;&gt;Computation in logic programming&lt;/h1&gt;

&lt;p&gt;We have to pause working on our toy language implementation for a bit to first explain a little bit
about how computation in Makam works.&lt;/p&gt;

&lt;p&gt;Say that instead of using Makam, we were using a functional language. One of the main operations
of functional languages is &lt;em&gt;pattern-matching&lt;/em&gt;: we try to match a term against a pattern; if
the match is successful, we proceed to take the corresponding branch.  Patterns are kind of like
&amp;ldquo;templates&amp;rdquo; for terms: some parts are explicitly specified, while others are allowed to be
arbitrary. Another way to say this, is that if terms are like trees, patterns are like &amp;ldquo;trees with
holes&amp;rdquo;:&lt;/p&gt;

&lt;p&gt;&lt;center&gt;&lt;img src=&#34;https://astampoulis.github.io/blog/makam-tutorial-01-pic2.svg&#34; alt=&#34;Pattern&#34; width=&#34;300&#34; /&gt;&lt;/center&gt;&lt;/p&gt;

&lt;p&gt;We give names to the holes, so as to be able to refer to them &amp;ndash; these are the &lt;em&gt;pattern variables&lt;/em&gt;.
Pattern matching basically tries to find a way to fill in these holes in the pattern so that it
matches the term exactly.  So its result when its successful is an instantiation (or substitution)
for the pattern variables:&lt;/p&gt;

&lt;p&gt;&lt;center&gt;&lt;img src=&#34;https://astampoulis.github.io/blog/makam-tutorial-01-pic3.svg&#34; alt=&#34;Pattern&#34; width=&#34;550&#34; /&gt;&lt;/center&gt;&lt;/p&gt;

&lt;p&gt;Here&amp;rsquo;s an example of a query that performs pattern matching between a pattern and a term in
Makam. We will talk about what queries &lt;em&gt;are&lt;/em&gt; later on, but if you run this post right now using the Play button
on the bottom-right corner, you will see that an instantiation for the pattern variables &lt;code&gt;N&lt;/code&gt;, &lt;code&gt;X&lt;/code&gt; is found:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-makam&#34;&gt;pattern_match
  (add (intconst N) X)
  (add (intconst 5) (intconst 3)) ?
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-makam-hidden&#34;&gt;&amp;gt;&amp;gt; Yes:
&amp;gt;&amp;gt; N := 5,
&amp;gt;&amp;gt; X := intconst 3.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Logic programming instead treats &lt;em&gt;unification&lt;/em&gt; as one of the key operations. This is the symmetric,
more general, version of pattern matching: instead of having a &amp;ldquo;pattern&amp;rdquo; with potentially unknown parts,
and a &amp;ldquo;term&amp;rdquo; that is fully known, we have two patterns that might both have unknown parts in them.
Matching them against each other might force instantiations on either one of them, or even on both of
them (in different parts of them); some parts might even remain unknown after the unification. The
unknown parts are called &lt;em&gt;unification variables&lt;/em&gt; and are denoted with identifiers starting with an
uppercase letter, whereas the identifiers of normal term constructors start with a lowercase letter.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-makam&#34;&gt;unify (add (intconst N1) X2) (add X1 (intconst N2)) ?
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-makam-hidden&#34;&gt;&amp;gt;&amp;gt; Yes:
&amp;gt;&amp;gt; X1 := intconst N1,
&amp;gt;&amp;gt; X2 := intconst N2,
&amp;gt;&amp;gt; N1 := N1,
&amp;gt;&amp;gt; N2 := N2.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;(Note the color-coding on the side of codeblocks of this post: blue blocks are things that will be sent
to Makam, which become green after a successful run, and grey ones are skipped. Any esults from the Makam
interpreter, or any errors, show up as annotations in each codeblock.)&lt;/p&gt;

&lt;p&gt;This choice has a wide-ranging implication on how computation in logic programming actually looks
like.  In a functional language, at the point where a function is applied, its inputs are fully
known (or at least fully knowable, in a call-by-need language), whereas outputs are fully unknown,
to be determined through evaluation of the function. In a logic programming language, there is no
need to explicitly separate inputs from outputs: both of them could only be partially known at the
point where a &amp;ldquo;function&amp;rdquo; is applied, and unification will reconcile the known and unknown parts.  So
instead of functions we talk about &lt;em&gt;predicates&lt;/em&gt;: these describe relations between terms, without
explicitly designating some of them as inputs and some as outputs. What is an input and what is an
output depends on the arguments that the predicates are called with. Here is an example of the
&lt;code&gt;plus&lt;/code&gt; predicate, which is the moral equivalent of the &lt;code&gt;a + b&lt;/code&gt; operation on integers:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-makam&#34;&gt;plus 1 2 X ?
plus X 2 3 ?
plus 1 X 3 ?
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So the &lt;code&gt;plus A B C&lt;/code&gt; predicate takes three arguments; the first two, &lt;code&gt;A&lt;/code&gt;, &lt;code&gt;B&lt;/code&gt;, are the operands, and
&lt;code&gt;C&lt;/code&gt;, the last one, is the result of the addition. However, the predicate can be used not only to
find the result of &lt;code&gt;A + B&lt;/code&gt;, but also to discover the value of &lt;code&gt;A&lt;/code&gt; or &lt;code&gt;B&lt;/code&gt; given the other operand and
the result.&lt;/p&gt;

&lt;p&gt;The type of the &lt;code&gt;plus&lt;/code&gt; predicate is:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-makam-noeval&#34;&gt;plus : (Op1: int) (Op2: int) (Result: int) -&amp;gt; prop.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The name of the type &lt;code&gt;prop&lt;/code&gt; comes from &lt;em&gt;proposition&lt;/em&gt;: these are the statements that we can query
upon, and might be viewed as the logic programming equivalent of the &lt;em&gt;expressions&lt;/em&gt; of a functional
programming language. So a fully applied predicate like &lt;code&gt;plus&lt;/code&gt; is a proposition, and by querying
about it as we did above, we are asking the Makam interpreter to find an instantiation for the
unknown &lt;em&gt;unification variables&lt;/em&gt; that makes the proposition hold.&lt;/p&gt;

&lt;p&gt;One might ask &amp;ndash; why is this generalization to unification and relations instead of functions
useful? One example where we can make good use of this in Makam is when implementing a type checking
procedure for a language, where blurring the line between inputs and outputs allows us to get a type
inferencing procedure essentially for free. But that is getting too much ahead of ourselves; we will
see more on later posts.&lt;/p&gt;

&lt;p&gt;With this out of the way, it is time to try our hand at writing our first predicate over the
expressions we defined.&lt;/p&gt;

&lt;h1 id=&#34;writing-an-interpreter-for-our-language&#34;&gt;Writing an interpreter for our language&lt;/h1&gt;

&lt;p&gt;Let&amp;rsquo;s go back to implementing our toy language now. Here is the base declaration of a predicate that
relates an expression of our language with the value it will result in upon evaluation. We can use
this predicate as an interpreter, if we give it a complete expression and a fully unknown value as
arguments.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-makam&#34;&gt;eval : (E: expr) (V: expr) -&amp;gt; prop.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here&amp;rsquo;s how we would use this, to evaluate/interpret a small example program:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-makam&#34;&gt;eval (add (intconst 1) (intconst 2)) Value ?
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Of course, this query fails at this point, as we have not given any kind of implementation for the
&lt;code&gt;eval&lt;/code&gt; predicate. We do this by giving &lt;em&gt;rules&lt;/em&gt; for the predicate: basically, we define the cases
for which the &lt;code&gt;eval Expr Value&lt;/code&gt; proposition holds. Each rule has a &lt;em&gt;goal&lt;/em&gt; and optional &lt;em&gt;premises&lt;/em&gt;.
Given the current query &lt;code&gt;Q&lt;/code&gt;, we attempt to unify it with the goal of each rule and proceed to
the premises, treating them as subsequent queries that need to be satisfied. For example, here are the cases
for integer constants and integer addition:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-makam&#34;&gt;eval (intconst I) (intconst I).
eval (add E1 E2) (intconst N) :-
  eval E1 (intconst N1),
  eval E2 (intconst N2),
  plus N1 N2 N.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The first rule says: integer constants evaluate to themselves (because they are already values).
The second one can be read as: the &lt;code&gt;add&lt;/code&gt; expression evaluates to an integer constant &lt;code&gt;N&lt;/code&gt;, when
the two operands evaluate to the integer constants &lt;code&gt;N1&lt;/code&gt; and &lt;code&gt;N2&lt;/code&gt;, and we also have &lt;code&gt;N = N1 + N2&lt;/code&gt;.
With these two rules, the query from above should now work:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-makam&#34;&gt;eval (add (intconst 1) (intconst 2)) Value ?
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-makam-hidden&#34;&gt;&amp;gt;&amp;gt; Yes:
&amp;gt;&amp;gt; Value := intconst 3.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;(Note that in a functional language when defining a function by pattern-matching, we &lt;em&gt;have&lt;/em&gt; to give
its full definition. In logic programming, we can add new rules for a predicate at any point of our
program, similarly to how we can add new constructors at any point.)&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s also add the cases for boolean constants, string constants and appending strings together. For
the latter one, we can use the Makam builtin string predicate &lt;code&gt;string.append&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-makam&#34;&gt;eval (boolconst B) (boolconst B).
eval (stringconst S) (stringconst S).
eval (add E1 E2) (stringconst S) :-
  eval E1 (stringconst S1),
  eval E2 (stringconst S2),
  string.append S1 S2 S.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Let&amp;rsquo;s try a couple more queries:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-makam&#34;&gt;eval (add (stringconst &amp;quot;foo&amp;quot;) (stringconst &amp;quot;bar&amp;quot;)) V ?
eval (add (intconst 5) (stringconst &amp;quot;foo&amp;quot;)) V ?
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-makam-hidden&#34;&gt;eval (add (stringconst &amp;quot;foo&amp;quot;) (stringconst &amp;quot;bar&amp;quot;)) V ?
&amp;gt;&amp;gt; Yes:
&amp;gt;&amp;gt; V := stringconst &amp;quot;foobar&amp;quot;.

eval (add (intconst 5) (stringconst &amp;quot;foo&amp;quot;)) V ?
&amp;gt;&amp;gt; Impossible.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Of course, the last query fails, as it should: we have only defined rules to handle the case where
the operands to &lt;code&gt;add&lt;/code&gt; evaluate to the same type of constant. That could be a deliberate choice
depending on how we want evaluation in our language to behave.&lt;/p&gt;

&lt;p&gt;How about arrays? For an array like &lt;code&gt;[1 + 2, &amp;quot;foo&amp;quot; + &amp;quot;bar&amp;quot;]&lt;/code&gt;, every member of the array needs to
be evaluated. We can use a helper predicate &lt;code&gt;eval_list&lt;/code&gt; to do that, as follows:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-makam-noeval&#34;&gt;eval_list : (Exprs: list expr) (Vals: list expr) -&amp;gt; prop.
eval (array ES) (array VS) :- eval_list ES VS.
eval_list [] [].
eval_list (E :: ES) (V :: VS) :- eval E V, eval_list ES VS.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We can do better than this though: remember when we said that Makam is a &lt;em&gt;higher-order&lt;/em&gt; logic
programming language? That means that we can define higher-order predicates (predicates that
take other predicates as arguments), similarly to how we can define higher-order functions
in a higher-order functional programming language. One example of such a predicate is &lt;code&gt;map&lt;/code&gt;
for lists, which is defined as follows in the Makam standard library:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-makam-noeval&#34;&gt;map Pred [] [].
map Pred (X :: XS) (Y :: YS) :- Pred X Y, map Pred XS YS.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Evaluation for arrays can thus be written as:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-makam&#34;&gt;eval (array ES) (array VS) :- map eval ES VS.

eval (array [
       add (intconst 1) (intconst 2),
       add (stringconst &amp;quot;foo&amp;quot;) (stringconst &amp;quot;bar&amp;quot;)])
     Value ?
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-makam-hidden&#34;&gt;&amp;gt;&amp;gt; Yes:
&amp;gt;&amp;gt; Value := array [ intconst 3, stringconst &amp;quot;foobar&amp;quot; ].
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Evaluating records is a little more complicated. We need to
evaluate the expressions contained within them, so that &lt;code&gt;{ foo: 1 + 1, bar: 2 + 2 }&lt;/code&gt;
evaluates to &lt;code&gt;{ foo: 2, bar: 4 }&lt;/code&gt;. However, we also need to decide
what to do about duplicate key entries, as in &lt;code&gt;{ foo: 1, foo: 2 }&lt;/code&gt;. For that, we will follow the JavaScript
semantics for objects: duplicate entries for the same key are allowed, and
the last occurrence of the same key is the one that gets picked &amp;ndash; so the
previous object evaluates to &lt;code&gt;{ foo: 2 }&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s see how to implement this in Makam. Here&amp;rsquo;s a first attempt where we
do not handle duplicate keys properly:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-makam-noeval&#34;&gt;eval (record []) (record []).
eval (record (mkfield Key Expr :: Rest))
     (record (mkfield Key Value :: Rest&#39;)) :-
  eval Expr Value,
  eval (record Rest) (record Rest&#39;).
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To account for duplicate keys, we need to split this last rule into two: one for the last occurrence
of a key (where the key does not appear in subsequent fields) and one for any earlier
occurrences. In this second case, the field can safely be ignored, as the language we are encoding
does not have any side effects. To distinguish the two cases, we can use an auxiliary predicate
that succeeds whenever a key exists within a list of fields:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-makam&#34;&gt;contains_key : (Fields: list field) (Key: string) -&amp;gt; prop.
contains_key (mkfield Key Expr :: Rest) Key.
contains_key (Field :: Rest) Key :-
  contains_key Rest Key.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And here&amp;rsquo;s the rules for evaluation:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-makam&#34;&gt;eval (record []) (record []).
eval (record (mkfield Key Expr :: Rest))
     (record Rest&#39;) :-
  contains_key Rest Key,
  eval (record Rest) (record Rest&#39;).
eval (record (mkfield Key Expr :: Rest))
     (record (mkfield Key Value :: Rest&#39;)) :-
  not(contains_key Rest Key),
  eval Expr Value, eval (record Rest) (record Rest&#39;).
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note the use of &lt;code&gt;not&lt;/code&gt; here: basically, we are saying that this last rule applies whenever
&lt;code&gt;contains_key Rest Key&lt;/code&gt; is not successful&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:1&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:1&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;.&lt;/p&gt;

&lt;p&gt;With these, the interpreter for our toy language is complete!&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-makam&#34;&gt;eval (record [
  mkfield &amp;quot;foo&amp;quot; (add (intconst 1) (intconst 1)),
  mkfield &amp;quot;bar&amp;quot; (array [ add (intconst 2) (intconst 2) ]),
  mkfield &amp;quot;foo&amp;quot; (add (intconst 4) (intconst 4))
]) V ?
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-makam-hidden&#34;&gt;&amp;gt;&amp;gt; Yes:
&amp;gt;&amp;gt; V := record [mkfield &amp;quot;bar&amp;quot; (array [intconst 4]), mkfield &amp;quot;foo&amp;quot; (intconst 8)].
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;defining-the-concrete-syntax-for-our-language&#34;&gt;Defining the concrete syntax for our language&lt;/h1&gt;

&lt;p&gt;One issue with our interpreter, which is quite evident in the query above, is that we have to use
abstract syntax for writing down the terms of our language &amp;ndash; and that&amp;rsquo;s not always pleasant.
Abstract syntax is often quite long-winded and verbose, even for simple terms.  It would be
nice to be able to use concrete syntax instead, to write queries like:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-makam-noeval&#34;&gt;evalstring &amp;lt;&amp;lt; { &amp;quot;foo&amp;quot;: &amp;quot;a&amp;quot;, &amp;quot;foo&amp;quot;: [ &amp;quot;bar&amp;quot;, 40 + 2 ] } &amp;gt;&amp;gt; Y ?
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;(The syntax form &lt;code&gt;&amp;lt;&amp;lt; .. &amp;gt;&amp;gt;&lt;/code&gt; is alternative syntax for strings in Makam, so that we don&amp;rsquo;t have to
escape the quotes &lt;code&gt;&amp;quot;&lt;/code&gt; within it.)&lt;/p&gt;

&lt;p&gt;What we need is a parser, that converts a &lt;code&gt;string&lt;/code&gt; containing concrete syntax into the abstract
syntax terms that we have defined. So we need to define a predicate with the type:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-makam-noeval&#34;&gt;parse_expr : (Concrete: string) (Abstract: expr) -&amp;gt; prop.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Let&amp;rsquo;s ruminate on this: given a query on &lt;code&gt;parse_expr&lt;/code&gt;, what would happen if the second argument was a
fully-known abstract syntax tree, whereas the first argument was fully unknown? In that case, we would
be reconstructing the concrete syntax of an abstract syntax tree &amp;ndash; namely, we would be using this
predicate as a pretty-printer for our terms.&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:2&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:2&#34;&gt;2&lt;/a&gt;&lt;/sup&gt; So maybe &lt;code&gt;parse_expr&lt;/code&gt; is not such a great name for our
predicate, since we could use it both as a parser and a pretty-printer of expressions.&lt;/p&gt;

&lt;p&gt;How about writing the predicate itself? Makam already has a &lt;code&gt;syntax&lt;/code&gt; library that can help us
implement syntax predicates like these by only giving a grammar for our language, similar to how
parser generators are used in other languages. The details of how the library works is a topic for
another time; it is also a relatively recent development, so its exact details might change.  For
now, I will just give an example of how to use it for the language we have defined in this post, and will
just say that the parsing aspect of the library is based
on &lt;a href=&#34;https://pdos.csail.mit.edu/papers/parsing:popl04.pdf&#34;&gt;PEG parsing&lt;/a&gt;&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:3&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:3&#34;&gt;3&lt;/a&gt;&lt;/sup&gt; and I am using an
adaptation
of
&lt;a href=&#34;http://www.mathematik.uni-marburg.de/~rendel/rendel10invertible.pdf&#34;&gt;Invertible Syntax Descriptions&lt;/a&gt;&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:4&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:4&#34;&gt;4&lt;/a&gt;&lt;/sup&gt;
to the PEG setting so that the same grammar is used both for parsing and pretty printing.&lt;/p&gt;

&lt;p&gt;Before looking at the code, let me briefly explain the components that go into it. First, we
need to define &amp;ldquo;syntax constructors&amp;rdquo; which are akin to typed non-terminals in grammars: for example,
a syntax constructor with the type &lt;code&gt;syntax expr&lt;/code&gt; will be used as a handle that allows us to parse
and pretty-print terms of type &lt;code&gt;expr&lt;/code&gt;. Then, we need to give syntactic rules, which describe how to
parse/pretty-print each term constructor (like &lt;code&gt;stringconst&lt;/code&gt;, &lt;code&gt;array&lt;/code&gt;, etc.). Last, we need to generate
parsing/pretty-printing code for each toplevel syntax constructor; this is akin to running a parser
generator to get the parsing code for our grammar. This step, just as all the other steps, happens
within the same Makam program instead of requiring an external parser generator.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-makam-hidden&#34;&gt;%open syntax.
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-makam&#34;&gt;baseexpr, expr : syntax expr.
field : syntax field.

`(syntax_rules &amp;lt;&amp;lt;

  expr -&amp;gt;
    add      { &amp;lt;baseexpr&amp;gt; &amp;quot;+&amp;quot; &amp;lt;expr&amp;gt; }
  / baseexpr ;

  baseexpr -&amp;gt;
    stringconst { &amp;lt;makam.string_literal&amp;gt; }
  / intconst    { &amp;lt;makam.int_literal&amp;gt; }
  / array       { &amp;quot;[&amp;quot; &amp;lt;list_sep (token &amp;quot;,&amp;quot;) expr&amp;gt; &amp;quot;]&amp;quot; }
  / record      { &amp;quot;{&amp;quot; &amp;lt;list_sep (token &amp;quot;,&amp;quot;) field&amp;gt; &amp;quot;}&amp;quot; }
  / { &amp;quot;(&amp;quot; &amp;lt;expr&amp;gt; &amp;quot;)&amp;quot; } ;

  field -&amp;gt;
    mkfield  { &amp;lt;makam.ident&amp;gt; &amp;quot;:&amp;quot; &amp;lt;expr&amp;gt; }
  / mkfield  { &amp;lt;makam.string_literal&amp;gt; &amp;quot;:&amp;quot; &amp;lt;expr&amp;gt; }

&amp;gt;&amp;gt;).
`( syntax.def_toplevel_js expr ).
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Let&amp;rsquo;s try parsing and pretty-printing out. We will use the &lt;code&gt;syntax.run&lt;/code&gt; predicate, which does
either of these two depending on its arguments:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-makam&#34;&gt;syntax.run expr &amp;quot;{ foo: 1, bar: 2 + 2 }&amp;quot; Expr ?
syntax.run expr String (record [ mkfield &amp;quot;foo&amp;quot; (intconst 5) ]) ?
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-makam-hidden&#34;&gt;&amp;gt;&amp;gt; syntax.run expr &amp;quot;{ foo: 1, bar: 2 + 2 }&amp;quot; Expr ?
&amp;gt;&amp;gt; Yes:
&amp;gt;&amp;gt; Expr := record [ mkfield &amp;quot;foo&amp;quot; (intconst 1), mkfield &amp;quot;bar&amp;quot; (add (intconst 2) (intconst 2)) ].

&amp;gt;&amp;gt; syntax.run expr String (record [ mkfield &amp;quot;foo&amp;quot; (intconst 5) ]) ?
&amp;gt;&amp;gt; Yes:
&amp;gt;&amp;gt; String := &amp;quot;{ foo : 5 } &amp;quot;.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;OK, let&amp;rsquo;s unpack the code above a bit and explain what goes into it. The toplevel syntax constructor
is &lt;code&gt;expr&lt;/code&gt;, which we will use to parse and pretty-print expressions of our language. We also make use
of two additional auxiliary syntaxes, one for base expressions and one for fields. &lt;code&gt;expr&lt;/code&gt; represents
the higher-precedence part of expressions &amp;ndash; right now, this just stands for infix addition &amp;ndash; while
base expressions are the lower-precedence ones, which is everything else. The syntax library does
not presently include any explicit support for describing precedence, and that&amp;rsquo;s why we had to split
into top-level and base expressions manually. Each syntax rule specifies the constructor that it is
parsing/pretty-printing, along with any number of tokens and other syntax expressions that are
needed. Each expression within the angle brackets needs to correspond to the type of each argument
of the constructor: for example, in the first rule for the &lt;code&gt;mkfield&lt;/code&gt; constructor, which requires a
string followed by an expression, &lt;code&gt;makam.ident&lt;/code&gt; is a syntax constructor of type &lt;code&gt;syntax string&lt;/code&gt; and
&lt;code&gt;expr&lt;/code&gt; is of type &lt;code&gt;syntax expr&lt;/code&gt;.  The &lt;code&gt;list_sep&lt;/code&gt; incantation for &lt;code&gt;array&lt;/code&gt; and &lt;code&gt;record&lt;/code&gt; is used to
parse/pretty-print a list with the specified separator, which here is the &lt;code&gt;&amp;quot;,&amp;quot;&lt;/code&gt; token.&lt;/p&gt;

&lt;p&gt;One thing to note about the workings of these rules is that contrary to context-free grammars, the rules
here are applied in order and the choice is deterministic: given two rules like &lt;code&gt;A / B&lt;/code&gt;, we attempt to
parse/pretty-print using &lt;code&gt;A&lt;/code&gt;, and only if that fails &lt;code&gt;B&lt;/code&gt; is attempted. This has implications both for
parsing and pretty-printing: for example, if we switch the order of rules for &lt;code&gt;expr&lt;/code&gt;, we will never get
to the rule for &lt;code&gt;add&lt;/code&gt; when parsing, as &lt;code&gt;baseexpr&lt;/code&gt; is already parseable on its own, and that&amp;rsquo;s the first
prerequisite for &lt;code&gt;add&lt;/code&gt;. For pretty-printing, the order of rules means that a record will be
printed as &lt;code&gt;{ foo: ... }&lt;/code&gt; instead of &lt;code&gt;{ &amp;quot;foo&amp;quot;: ... }&lt;/code&gt; for keys that are identifiers; the string notation
will be used otherwise. Another note is that left recursion is not permitted, hence we could
not have a rule for &lt;code&gt;add&lt;/code&gt; like &lt;code&gt;&amp;lt;expr&amp;gt; &amp;quot;+&amp;quot; &amp;lt;expr&amp;gt;&lt;/code&gt; but need to break the recursion through &lt;code&gt;baseexpr&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Last, one small note for the syntax of Makam itself and how these definitions actually work: the
`&lt;code&gt;(&lt;/code&gt; notation stands for a call to a staging predicate: that is, a predicate that generates further
Makam code that is &amp;ldquo;inserted&amp;rdquo; in place. Here, &lt;code&gt;syntax_rules&lt;/code&gt; transforms these grammar rules (given
as a plain string with the notation &lt;code&gt;&amp;lt;&amp;lt; .. &amp;gt;&amp;gt;&lt;/code&gt;) into normal Makam rules that define parsing and
pretty-printing; whereas &lt;code&gt;syntax.def_toplevel_js&lt;/code&gt; generates some JavaScript code that is then inserted
into a normal Makam predicate that will be used for parsing.&lt;/p&gt;

&lt;p&gt;With &lt;code&gt;syntax.run expr&lt;/code&gt; defined, we can now define a predicate that is more akin
to the input-output portion of a REPL for our language, that takes an expression as
a concrete string as input, evaluates it and returns the result as a string again:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-makam&#34;&gt;evalstring : (ExprStr: string) (ValueStr: string) -&amp;gt; prop.
evalstring ExprStr ValueStr :-
  syntax.run expr ExprStr Expr,
  eval Expr Value,
  syntax.run expr ValueStr Value.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We can now issue queries to try out our whole implementation so far. Note that
this query block is editable, so you can try your own queries as well:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-makam-input&#34;&gt;evalstring &amp;lt;&amp;lt; { &amp;quot;foo&amp;quot;: &amp;quot;a&amp;quot;, &amp;quot;foo&amp;quot;: [ &amp;quot;bar&amp;quot;, 40 + 2 ] } &amp;gt;&amp;gt; X ?
evalstring &amp;lt;&amp;lt; [ 1 + (12 + 12) ] &amp;gt;&amp;gt; X ?
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-makam-hidden&#34;&gt;&amp;gt;&amp;gt; evalstring &amp;lt;&amp;lt; { &amp;quot;foo&amp;quot;: &amp;quot;a&amp;quot;, &amp;quot;foo&amp;quot;: [ &amp;quot;bar&amp;quot;, 40 + 2 ] } &amp;gt;&amp;gt; X ?
&amp;gt;&amp;gt; Yes:
&amp;gt;&amp;gt; X := &amp;quot;{ foo : [ \&amp;quot;bar\&amp;quot; , 42 ] } &amp;quot;.

&amp;gt;&amp;gt; evalstring &amp;lt;&amp;lt; [ 1 + (12 + 12) ] &amp;gt;&amp;gt; X ?
&amp;gt;&amp;gt; Yes:
&amp;gt;&amp;gt; X := &amp;quot;[ 25 ] &amp;quot;.
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;conclusion&#34;&gt;Conclusion&lt;/h1&gt;

&lt;p&gt;We did cover quite a bit of stuff here: concrete and abstract syntax, the very basics of computation
in logic programming, and writing an interpreter for a very simple language. Next time we will cover
how to encode more complicated constructs, like functions, how to implement a type checker for our
language in Makam, and more on the basics of higher-order logic programming.&lt;/p&gt;
&lt;div class=&#34;footnotes&#34;&gt;

&lt;hr /&gt;

&lt;ol&gt;
&lt;li id=&#34;fn:1&#34;&gt;Negation in logic programming languages is a big topic, mostly because it breaks many of the invariants that hold about the language otherwise. For example: adding a new rule only makes more queries succeed, instead of making queries fail when they were previously succeeding; this does not hold in the presence of negation.
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:1&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:2&#34;&gt;The reality is more complicated of course &amp;ndash; using the same predicate for both kinds of queries is not always possible for free, or will not always terminate. In a later post, we will explore this more in-depth.
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:2&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:3&#34;&gt;Bryan Ford. 2004. &lt;em&gt;Parsing expression grammars: a recognition-based syntactic foundation&lt;/em&gt;. In Proceedings of the 31st ACM SIGPLAN-SIGACT symposium on Principles of programming languages (POPL &amp;lsquo;04). ACM, New York, NY, USA, 111-122. DOI: &lt;a href=&#34;http://dx.doi.org/10.1145/964001.964011&#34;&gt;http://dx.doi.org/10.1145/964001.964011&lt;/a&gt;
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:3&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:4&#34;&gt;Tillmann Rendel and Klaus Ostermann. 2010. &lt;em&gt;Invertible syntax descriptions: unifying parsing and pretty printing&lt;/em&gt;. In Proceedings of the third ACM Haskell symposium on Haskell (Haskell &amp;lsquo;10). ACM, New York, NY, USA, 1-12. DOI: &lt;a href=&#34;https://doi.org/10.1145/1863523.1863525&#34;&gt;https://doi.org/10.1145/1863523.1863525&lt;/a&gt;
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:4&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;</description>
    </item>
    
    
    
    <item>
      <title>Literate Makam web pages and other recent news</title>
      <link>https://astampoulis.github.io/blog/makam-webui-etc/</link>
      <pubDate>Sun, 04 Feb 2018 11:27:37 -0500</pubDate>
      <author>antonis DOT stampoulis AT gmail DOT com (Antonis Stampoulis)</author>
      <guid>https://astampoulis.github.io/blog/makam-webui-etc/</guid>
      <description>&lt;p&gt;I have been working a lot on Makam in the past few months, the
metalanguage based on λProlog that I started implementing at MIT
working with &lt;a href=&#34;http://adam.chlipala.net&#34;&gt;Adam Chlipala&lt;/a&gt;.  The latest
feature I have been working on is a Web interface for Makam, meant to
be used for literate posts that have Makam code alongside the
text. The code is ran through a AWS Lambda Makam webservice. This is
the first such literate post &amp;ndash; so go ahead and evaluate the code of
this web page, or even try editing the final queries before
evaluating, using the two buttons on the bottom-right of the page!&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;p&gt;It goes without saying what the first query utilizing this interface
should be:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-makam-hidden&#34;&gt;post: testsuite. %testsuite post.
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-makam&#34;&gt;print_string &amp;quot;Hello world!\n&amp;quot; ?
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-makam-hidden&#34;&gt;&amp;gt;&amp;gt; Yes.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &amp;ldquo;Yes.&amp;rdquo; part you might notice in the result of this query means
that a solution was found. Typically, Makam queries will have
uninstantiated metavariables (that start with a capital letter), and
the point of executing them would be to find valid solutions for those
variables. More on these below.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-makam&#34;&gt;string.concat [&amp;quot;Hello&amp;quot;, &amp;quot; &amp;quot;, X, &amp;quot;!&amp;quot;] &amp;quot;Hello world!&amp;quot; ?
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-makam-hidden&#34;&gt;&amp;gt;&amp;gt; Yes:
&amp;gt;&amp;gt; X := &amp;quot;world&amp;quot;.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now that this interface is ready, I am planning to start a number of
tutorials on Makam and on language implementation. I also have a few
experimental ideas that I want to implement, where I would appreciate
some feedback, but that is a matter for a later time.  In any
case, &lt;a href=&#34;mailto:antonis DOT stampoulis AT gmail DOT com&#34;&gt;drop me a line&lt;/a&gt; with your
thoughts if you are reading this!&lt;/p&gt;

&lt;p&gt;Makam is meant to be used as a PL prototyping tool to explore research
ideas, and also as tool for encoding and understanding existing
languages and advanced type systems. It aims to be more of a very
expressive core language that can be used to define languages and
transformations between languages in a concise way, even when those
are quite involved.  In that sense, it does not aim to be a language
workbench that allows you to define specific aspects of your language
using different domain specific languages (e.g. parsing, name
resolution, typing, etc.), and gives you a full-blown IDE experience
as a result (for example, in the style
of &lt;a href=&#34;http://www.metaborg.org/en/latest/&#34;&gt;Spoofax&lt;/a&gt;). However, a lot of
the DSLs and tools that would comprise a language workbench in that
style can be implemented within Makam itself.&lt;/p&gt;

&lt;p&gt;One such DSL that I have defined lately is a bidirectional syntax
language. It can be used to define a parser and a pretty-printer for
the language you are implementing, through a single set of rules
(hence the &amp;lsquo;bidirectionality&amp;rsquo; in the name refers to viewing parsers
and pretty-printers as inverses of each other). The pretty-printing
part is quite basic at this point, but the parsing part is at a
relatively good state: it is based on PEG parser combinators, and it
generates parsing code in JavaScript that runs in Node.js under the
hood. This is done because Makam is interpreted and quite slow to
evaluate, so running the parsers in Node is a huge performance
boost. Of course, the parser generation, which transforms terms of the
PEG combinator language to JavaScript code, is implemented in Makam.&lt;/p&gt;

&lt;p&gt;Other things that I have been working on recently is a concrete
binding library, to convert between abstract syntax with concrete
names and abstract binding syntax utilizing HOAS; a testing framework;
and various additions to the standard library.  There&amp;rsquo;s now an &lt;code&gt;npm&lt;/code&gt;
package for Makam too with precompiled binaries for Linux and MacOS X,
if you want to execute Makam locally and do not already have OCaml
installed. With these, I felt like a version bump was in order, so
this also marks the release of Makam 0.7.0.&lt;/p&gt;

&lt;p&gt;As a small example of the syntax DSL, let&amp;rsquo;s implement a simple calculator
language and its syntax description. I will not go into full details, so
stay tuned for a more in-depth introductory post along the same
lines. First, we will define the terms of our language&amp;ndash; let&amp;rsquo;s say we
have integer constants, integer addition, &lt;code&gt;let&lt;/code&gt; expressions and variables.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-makam&#34;&gt;term : type.

intconst : int -&amp;gt; term.
add : term -&amp;gt; term -&amp;gt; term.
let : string -&amp;gt; term -&amp;gt; term -&amp;gt; term.
var : string -&amp;gt; term.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now let&amp;rsquo;s define the syntax for these. We split the syntax into
two precedence levels, and then give a syntax rule for each
term constructor. The angle brackets means that the result of
a parsing expression gets applied to the given term constructor &amp;ndash;
so each rule needs to apply the right kind of arguments in sequence.
Quoted strings stand for tokens.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-makam&#34;&gt;term, baseterm : syntax term.

`( syntax_rules {{

term -&amp;gt;
  add { &amp;lt;baseterm&amp;gt; &amp;quot;+&amp;quot; &amp;lt;term&amp;gt; }
/ let { &amp;quot;let&amp;quot; &amp;lt;makam.ident&amp;gt; &amp;quot;=&amp;quot; &amp;lt;term&amp;gt; &amp;quot;in&amp;quot; &amp;lt;term&amp;gt; }
/ baseterm
;

baseterm -&amp;gt;
  intconst { &amp;lt;makam.int_literal&amp;gt; }
/ var { &amp;lt;makam.ident&amp;gt; }
/ { &amp;quot;(&amp;quot; &amp;lt;term&amp;gt; &amp;quot;)&amp;quot; }

}}).

`( syntax.def_toplevel_js term ).
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The two statements starting with the `&lt;code&gt;(&lt;/code&gt; symbol are staged,
meaning that they are Makam programs that compute Makam
programs which are then evaluated in place. The former one
translates the surface-level syntax for syntax rules to
actual Makam rules; and the latter one generates a top-level
parser in JavaScript for the &lt;code&gt;term&lt;/code&gt;. The double-bracket
notation stands for multi-line strings, which is useful
when writing code of a different language.&lt;/p&gt;

&lt;p&gt;With these, we can issue parsing queries. For example:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-makam&#34;&gt;syntax.parse_opt term {{ let a = 21 in a + a }} X ?
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-makam-hidden&#34;&gt;&amp;gt;&amp;gt; Yes:
&amp;gt;&amp;gt; X := let &amp;quot;a&amp;quot; (intconst 21) (add (var &amp;quot;a&amp;quot;) (var &amp;quot;a&amp;quot;)).
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Let&amp;rsquo;s also define an evaluator for this language that returns the
result of an expression. This will be a predicate that relates a term
of the language to its integer value:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-makam&#34;&gt;eval : term -&amp;gt; int -&amp;gt; prop.

eval (intconst N) N.
eval (add E1 E2) N :-
  eval E1 N1, eval E2 N2,
  plus N1 N2 N.
eval (let VAR DEF BODY) N :-
  eval DEF N_DEF,
  (eval (var VAR) N_DEF -&amp;gt; eval BODY N).
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We can also define a version of the &lt;code&gt;eval&lt;/code&gt; predicate that accepts a
string as input, and parses the string before evaluating. Makam has
type-based overloading for constants, so types are used to
disambiguate between the two &lt;code&gt;eval&lt;/code&gt; predicates:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-makam&#34;&gt;eval : string -&amp;gt; int -&amp;gt; prop.
eval String Result :-
  syntax.parse_opt term String Term,
  eval Term Result.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Our simple calculator is ready! Here&amp;rsquo;s an example query:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-makam-hidden&#34;&gt;&amp;gt;&amp;gt; eval {{ let a = 21 in a + a }} X ?
&amp;gt;&amp;gt; Yes:
&amp;gt;&amp;gt; X := 42.
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-makam-input&#34;&gt;eval {{ let a = 21 in a + a }} X ?
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Using the Makam web interface, you can edit the query above &amp;ndash; the
Edit button on the bottom-right takes you directly to it &amp;ndash; and re-run
Makam to see the result with the Play button. (For the time being,
only the query is editable, mostly to limit the AWS Lambda execution
times; in the future, the rest of the Makam code blocks in a post
might be editable as well if that proves useful.)&lt;/p&gt;

&lt;p&gt;That&amp;rsquo;s it for the time being! More introductory tutorial posts should
be coming up soon!&lt;/p&gt;</description>
    </item>
    
    
    
    <item>
      <title>Welcome!</title>
      <link>https://astampoulis.github.io/blog/welcome/</link>
      <pubDate>Tue, 08 Sep 2015 13:57:59 -0400</pubDate>
      <author>antonis DOT stampoulis AT gmail DOT com (Antonis Stampoulis)</author>
      <guid>https://astampoulis.github.io/blog/welcome/</guid>
      <description>&lt;p&gt;I&amp;rsquo;m starting this blog as a way to post tutorial series on Makam, plus random thoughts.
I&amp;rsquo;m thinking of one series for programmers who want to learn more
about programming language theory, type systems, formal semantics, etc.; and another
one for programming language researchers who would like to use Makam to experiment
with new type system ideas.&lt;/p&gt;
</description>
    </item>
    
    
    
    
    
    
    
    
    
    
    
    
  </channel>
</rss>
