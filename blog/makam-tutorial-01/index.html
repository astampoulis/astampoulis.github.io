<!doctype html>
<html lang="en">
<head>

  
  <meta charset="utf-8">
  <title>Makam Tutorial 1: Prototyping a toy language and its interpreter</title>
  <meta name="description" content="Makam Tutorial 1: Prototyping a toy language and its interpreter">
  <meta name="author" content="Antonis Stampoulis">

  
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link href="//fonts.googleapis.com/css?family=Raleway:400,300,600" rel="stylesheet" type="text/css">
  <link rel="stylesheet" href="https://astampoulis.github.io/css/fonts.css">
  
  
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/pure/1.0.0/pure-min.css" integrity="sha256-Q0zCrUs2IfXWYx0uMKJfG93CvF6oVII21waYsAV4/8Q=" crossorigin="anonymous" />
  

    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/pure/1.0.0/grids-responsive-min.css" integrity="sha256-YqnnS/cQ7vE7gfVjdfx+JMi5EFD6m6Zqdemj81rs6PU=" crossorigin="anonymous" />

  <link rel="stylesheet" href="https://astampoulis.github.io/css/custom.css">

  <script language="javascript">window.makamWebUIOptions = { env: "prod", urlOfDependency: (filename) => new URL("../" + filename, document.baseURI).href };</script>
  <script src="https://unpkg.com/makam-webui"></script>

  
  <script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-MML-AM_CHTML'></script>
  <script type="text/x-mathjax-config">
   MathJax.Hub.Config({
       tex2jax: {
           inlineMath: [['$','$'], ['$-', '-$'], ['\\(','\\)']],
           displayMath: [['$$','$$']],
           processEscapes: true,
           processEnvironments: true,
           skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
           TeX: { equationNumbers: { autoNumber: "AMS" },
                  extensions: ["AMSmath.js", "AMSsymbols.js"] }
       }
   });
  </script>

  
  
  <link href="https://astampoulis.github.io/index.xml" rel="alternate" type="application/rss+xml" title="Antonis Stampoulis" />
  <link href="https://astampoulis.github.io/index.xml" rel="feed" type="application/rss+xml" title="Antonis Stampoulis" />

</head>
<body>
<div class="container">


<div class="header pure-g">
    <div class="pure-u-1-24 pure-u-md-1-4"></div>
    <div class="pure-u-11-12 pure-u-md-1-2">
        <div class="desktop pure-menu pure-menu-horizontal nav-menu">
            
            <a href="/" class="site-title pure-menu-heading">Antonis Stampoulis</a>
            <ul class="pure-menu-list">
                <li class="pure-menu-item">
                    <a href="https://astampoulis.github.io/blog" class="pure-menu-link">Blog</a>
                </li>
                <li class="pure-menu-item">
                    <a href="https://astampoulis.github.io/" class="pure-menu-link">About</a>
                </li>
                <li class="pure-menu-item">
                    <a href="https://github.com/astampoulis" class="pure-menu-link">GitHub</a>
                </li>
            </ul>
            <div style="clear: both;"></div>
        </div>
        <div class="mobile pure-menu nav-menu">
            <a href="/" class="pure-menu-heading" id="toggle-home">Antonis Stampoulis</a>
            <a href="#" id="toggle-btn">&#9776;</a>
            <ul class="pure-menu-list" id="toggle-content" style="display:none;">
                
                <li class="pure-menu-item">
                    <a href="https://astampoulis.github.io/blog" class="pure-menu-link">Blog</a>
                </li>
                <li class="pure-menu-item">
                    <a href="https://astampoulis.github.io/" class="pure-menu-link">About</a>
                </li>
            </ul>
        </div>
    </div>
    <div class="pure-u-1-24 pure-u-md-1-4"></div>
</div>


<div class="pure-g" id="maincontainer">
    <div class="pure-u-1-24 pure-u-md-1-4"></div>
	<div class="pure-u-11-12 pure-u-md-1-2">
        <div class="post">

            <div class="post-title">
                <p class="footnote">
                    
                    <time class="">2018-03-19</time>
                    
		    

                    
                    

                    

                    
                </p>
                
                <h1>Makam Tutorial 1: Prototyping a toy language and its interpreter</h1>
                
            </div>

            <div class="post-content">
                

<p><em>In this post, we&rsquo;ll implement a toy interpreter for a small functional language. We will use Makam,
a metalanguage that helps in the &lsquo;initial spiking/prototyping phase&rsquo; of designing a new language, allowing
for a tight feedback loop and for iterating quickly.</em></p>

<pre><code class="language-makam-hidden">tests : testsuite. %testsuite tests.
</code></pre>

<p>Say you are designing and implementing a new language: there is a class of programs that are
hard to write in languages that are presently available and you want better ways to express them.</p>

<p>There are a lot of decisions to make. For starters, <em>what should the constructs of the language
be</em>?  How do these constructs enable writing the example programs that you have in mind? Which
constructs should be the &ldquo;core&rdquo; ones of the language, and which ones should be defined in terms of
them?</p>

<p>What does it mean to use the language? How do you write programs in it — what&rsquo;s the syntax like,
what information can one get about their programs (and how much of it can be inferred)?  What do the
constructs of the language mean — how do you compute with them, how do they relate to the
constructs in existing languages?</p>

<p>Coming up with answers to these questions is an iterative process: you can start with some answers,
try to write example programs, see what works and what does not, and adapt accordingly. Implementing
the language is quite crucial to this process: actually using the language reveals patterns that are
important but that you couldn&rsquo;t necessarily have found otherwise — so that informs how to refine
the language further and what constructs to add.</p>

<p>Still, implementing a language takes a long time, which hinders this experimentation and refinement
process. There is <em>typically</em> a long feedback loop involved between having a new language design idea and
having a working (even toy-ish) implementation of it&hellip; but there doesn&rsquo;t have to be!</p>

<p>Minimizing this feedback loop is exactly why I have been working on the design and implementation of
<strong>Makam</strong>, a <strong>metalanguage</strong> that helps with the design and implementation of (prototypes of) new
languages. This way it allows you to iterate, validate and refine your language ideas quickly.</p>

<p>Makam is a dialect of <a href="http://www.lix.polytechnique.fr/~dale/lProlog/">λProlog</a> and is hence a
<em>higher-order logic programming language</em> (more on what that means later); I worked on it
with <a href="http://adam.chlipala.net">Adam Chlipala</a> while I was a post-doc at MIT. Since then,
development has been on an on-and-off basis as a personal project while
at <a href="http://www.originate.com">Originate</a>, but over the past six months or so I&rsquo;ve been working quite
a bit on it.</p>

<p>This post contains Makam code that you can run using the Play button on the bottom-right corner; you
can also edit the final code block to try out your own examples (the second button will take you
there). You can also follow
the <a href="https://github.com/astampoulis/makam#installation">installation instructions</a> for Makam and run
this post on your machine if
you
<a href="https://astampoulis.github.io/blog/makam-tutorial-01.md">download the source code for this post</a> and
do &ldquo;<code>makam makam-tutorial-01.md -</code>&rdquo;.</p>

<p>In this series of posts, we will use Makam to prototype various parts of a toy programming
language. We will also talk through the current set of answers of the lambda-Prolog/Makam language
design, in terms of what the base constructs are, and what can be programmed using those.</p>

<p>A caveat before we start is that many things are work-in-progress. Though the base language and
implementation are pretty well established at this point, Makam is still in a state of evolution and
refinement. Mostly, I am exploring what further tools are needed for doing language prototyping
effectively and implementing those for Makam, using Makam itself.</p>

<h1 id="expressing-the-main-constructs-of-our-language-abstract-syntax">Expressing the main constructs of our language: Abstract syntax</h1>

<p>Let&rsquo;s start defining and implementing our toy language. First of all, we will need to decide what
our base constructs are. To keep things simple let&rsquo;s start with this:</p>

<ul>
<li>String constants like <code>&quot;foo&quot;</code>, <code>&quot;bar&quot;</code></li>
<li>Integer constants like <code>5</code>, <code>42</code></li>
<li>Boolean constants, namely <code>true</code> and <code>false</code></li>
<li>An expression to add two integers or two strings together</li>
<li>Array literal expressions, like <code>[40 + 2, &quot;foo&quot;]</code></li>
<li>Record literal expressions, like <code>{ foo: &quot;bar&quot; }</code></li>
</ul>

<p>Here is a more formal way where you might see this kind of definition of language constructs on paper:</p>

<p><code>$$\begin{array}{llll}
e &amp; \text{(expressions)} &amp; ::= &amp; s \; | \; n \; | \; b \; | \; e_1 + e_2 \; | \; [ e_1, \cdots, e_n ] \; | \; \\
                         &amp; &amp; &amp;   \{ s_1: e_1, \cdots, s_n: e_n \} \\
s &amp; \text{(string constants)} &amp; ::= &amp; \cdots \\
n &amp; \text{(integer constants)} &amp; ::= &amp; \cdots \\
b &amp; \text{(boolean constants)} &amp; ::= &amp; \text{true} \; | \; \text{false}
\end{array}$$</code></p>

<p>In this notation, <em>expressions</em>, <em>string constants</em>, <em>integer constants</em> etc. are different <strong>sorts</strong> —
the different &ldquo;kinds of things&rdquo; that might be involved in the terms of our language.  For example,
if we were encoding an imperative language that included statements and statement blocks, we would
have separate sorts for them, like:</p>

<p><code>$$\begin{array}{llll}
st &amp; \text{(statements)} &amp; ::= &amp; x = e; \; | \; \text{return} \; e;
    \; | \; \text{if} \; (e) \; \text{then} \; b_1 \; \text{else} \; b_2; \; | \; \\
&amp; &amp; &amp; 
    \text{for} \; (\text{var} \; x \; \text{in} \; e) \; b;
    \; | \; \text{for} \; (\text{var} \; x \; \text{of} \; e) \; b; \; | \; \cdots \\
b &amp; \text{(blocks)} &amp; ::= &amp; \{ \; st_1 \; \cdots \; st_n \; \}
\end{array}$$</code></p>

<p>Each alternative given for a sort is a <strong>constructor</strong>. When we read a constructor definition like
&ldquo;$e_1 + e_2$&rdquo; it means that it&rsquo;s a constructor for expressions that is formed by two expressions. Similarly,
&ldquo;$\text{if} \; (e) \; \text{then} \; b_1 \; \text{else} \; b_2;$&rdquo; is formed by an expression
and two blocks. A constructor of the form &ldquo;$[ e_1, \cdots, e_n ]$&rdquo; means that it is formed through
a list of expressions. So the letters we give to sorts (like $e$, $s$) are a handy pun that
allows us to specify the constituent parts of each constructor concisely.</p>

<p>Now this notation mixes a couple of things together: we are defining <em>what the constructors are</em>
together with <em>what is the real syntax that we will use to write down those constructors</em>.
However, we can separate those two aspects of the definition out. In terms of what the
language <em>is</em>, the important part is <em>what the constructors are</em>. The syntax that we use
for them is secondary: it is important in terms of actually writing down terms of the language
in a way that is human-readable, but we could have different syntaxes for the same exact language.</p>

<p>Instead, we can separate those two concerns into two parts: one where we just give an explicit name
to each constructor and describe what its constituents are (how many are there and of what sorts) —
on paper, we could denote that with something like &ldquo;$\text{add}(e_1, e_2)$&ldquo;; and one where we
describe what the real syntactic form for the constructor is when we write out a program in the
language. When we talk about <strong>abstract syntax</strong>, we refer to the first part; and <strong>concrete
syntax</strong> is the latter one.</p>

<p>Let&rsquo;s now see how we would encode these in Makam.</p>

<p>First of all, we define the <em>sorts</em> that we need, which are referred to as <em>types</em> in Makam.
For our simple language, we just need expressions:</p>

<pre><code class="language-makam">expr : type.
</code></pre>

<p>There are built-in sorts for strings and integers in Makam; booleans and lists are already defined
in its standard library. Like in most functional languages, all elements of a list are of the same
type. So lists of expressions are a different type than, say, lists of strings: <code>list expr</code>
vs. <code>list string</code>. There&rsquo;s two ways to write down a list; either in the form <code>[1, 2, 3]</code>, or
in the form <code>1 :: 2 :: 3 ::  Nil</code>, similar to other functional languages.</p>

<p>With these in mind, we can define the constructors for expressions as follows. This corresponds
to the definition of the abstract syntax of our language, as mentioned above:</p>

<pre><code class="language-makam">stringconst : (S: string) -&gt; expr.
intconst : (I: int) -&gt; expr.
boolconst : (B: bool) -&gt; expr.
add : (E1: expr) (E2: expr) -&gt; expr.
array : (ES: list expr) -&gt; expr.
</code></pre>

<p>So we first give the name of the constructor, like <code>add</code>, the arguments it takes (that is, its
constituent parts), like <code>(E1: expr) (E2: expr)</code>, and the resulting sort that it belongs to, like
<code>expr</code>, following the arrow.  The names of the arguments, like <code>E1</code> and <code>E2</code>, are only given as
documentation. This helps sometimes to disambiguate between what each different argument is — for
example, we could define the <code>if</code>-<code>then</code>-<code>else</code> statement as:</p>

<pre><code class="language-makam-noeval">ifthenelse :
  (Condition: expr) (Then: block) (Else: block) -&gt; statement.
</code></pre>

<p>Terms built out from constructors like these correspond exactly to abstract syntax trees. For example,
the abstract syntax tree for the concrete syntax <code>5 + 3</code> would be:</p>

<p><center><img src="/blog/makam-tutorial-01-pic1.svg" alt="Abstract syntax tree" width="300" /></center></p>

<p>We would write this as <code>add (intconst 5) (intconst 3)</code> in Makam.</p>

<p>You might find something about the above definitions weird at first, coming from a language like
Haskell from ML. Typically in functional languages we define datatypes and give all of their
constructors as part of a single declaration. Here, however, we have defined new types and new
constructors for those types as separate statements. In Makam, this different style of definitions
allows us to define new constructors for an existing type at any point. This is a key departure of
Makam/lambda-Prolog from traditional functional languages; the next post will be mostly about this
feature and what it allows us to do. For the time being though, we can say that one case where this
feature is useful is developing a language in stages: for example, we can define a &lsquo;base version&rsquo; of
a language first, and then add some extra constructs later, in a separate place, without having to
change the base definition.</p>

<p>We have left the constructor for records out. We can view a record as a list of fields, where each
field pairs together a key with a value:</p>

<pre><code class="language-makam">field : type.
record : (Fields: list field) -&gt; expr.
mkfield : (Key: string) (Val: expr) -&gt; field.
</code></pre>

<p>And that covers all the constructors we&rsquo;ll define for the time being. Now let&rsquo;s see how to actually
define <em>computations</em> over these terms. Our example will be an interpreter for our language
that computes the value that an expression evaluates to.</p>

<h1 id="computation-in-logic-programming">Computation in logic programming</h1>

<p>We have to pause working on our toy language implementation for a bit to first explain a little bit
about how computation in Makam works.</p>

<p>Say that instead of using Makam, we were using a functional language. One of the main operations
of functional languages is <em>pattern-matching</em>: we try to match a term against a pattern; if
the match is successful, we proceed to take the corresponding branch.  Patterns are kind of like
&ldquo;templates&rdquo; for terms: some parts are explicitly specified, while others are allowed to be
arbitrary. Another way to say this, is that if terms are like trees, patterns are like &ldquo;trees with
holes&rdquo;:</p>

<p><center><img src="/blog/makam-tutorial-01-pic2.svg" alt="Pattern" width="300" /></center></p>

<p>We give names to the holes, so as to be able to refer to them — these are the <em>pattern variables</em>.
Pattern matching basically tries to find a way to fill in these holes in the pattern so that it
matches the term exactly.  So its result when it&rsquo;s successful is an instantiation (or substitution)
for the pattern variables:</p>

<p><center><img src="/blog/makam-tutorial-01-pic3.svg" alt="Pattern" width="550" /></center></p>

<p>Here&rsquo;s an example of a query that performs pattern matching between a pattern and a term in
Makam. We will talk about what queries <em>are</em> later on, but if you run this post right now using the Play button
on the bottom-right corner, you will see that an instantiation for the pattern variables <code>N</code>, <code>X</code> is found:</p>

<pre><code class="language-makam">pattern_match
  (add (intconst N) X)
  (add (intconst 5) (intconst 3)) ?
</code></pre>

<pre><code class="language-makam-hidden">&gt;&gt; Yes:
&gt;&gt; N := 5,
&gt;&gt; X := intconst 3.
</code></pre>

<p>Logic programming instead allows terms to <em>include unknown parts</em> in them and treats <em>unification</em>
as one of the key operations.  This is the symmetric, more general, version of pattern matching:
instead of having a &ldquo;pattern&rdquo; with potentially unknown parts on the left, and a fully known &ldquo;term&rdquo;
on the right, we have two terms with potentially unknown parts in them, and we are trying to
reconcile them against each other. This process might force instantiations on either one of them,
making previously unknown parts known, or even on both of them (in different parts of them). Some
things might even remain unknown after the unification. To be able to refer to them, we give names
to the unknown parts — so an unknown part is a special kind of a variable, referred to as a
<em>unification variables</em>.</p>

<p><center><img src="/blog/makam-tutorial-01-pic4.svg" alt="Pattern" width="550" /></center></p>

<p>In Makam, unification variables are denoted with identifiers starting with
uppercase letters, whereas the identifiers of normal term constructors start with lowercase letters.
Here&rsquo;s an example of a query that performs unification between two terms, corresponding to the example
above:</p>

<pre><code class="language-makam">unify (add (intconst N1) X2) (add X1 (intconst N2)) ?
</code></pre>

<pre><code class="language-makam-hidden">&gt;&gt; Yes:
&gt;&gt; X1 := intconst N1,
&gt;&gt; X2 := intconst N2,
&gt;&gt; N1 := N1,
&gt;&gt; N2 := N2.
</code></pre>

<p>(Note the color-coding on the side of codeblocks of this post: blue blocks are things that will be sent
to Makam, which become green after a successful run, and grey ones are skipped. Any results from the Makam
interpreter, or any errors, show up as annotations in each codeblock.)</p>

<p>This choice has a wide-ranging implication on how computation in logic programming actually looks.
In a functional language, at the point where a function is applied, its inputs are fully known (or
at least fully knowable, in a call-by-need language), whereas outputs are fully unknown, to be
determined through evaluation of the function. In a logic programming language, there is no need to
explicitly separate inputs from outputs: both of them could only be partially known at the point
where a &ldquo;function&rdquo; is applied, and unification will reconcile the known and unknown parts.  So
instead of functions we talk about <em>predicates</em>: these describe relations between terms, without
explicitly designating some of them as inputs and some as outputs. What is an input and what is an
output depends on the arguments that the predicates are called with. Here is an example of the
<code>append</code> predicate for lists:</p>

<pre><code class="language-makam">append [1,2,3] [4,5,6] ZS ?
append [1,2,3] YS [1,2,3,4,5,6] ?
append XS [4,5,6] [1,2,3,4,5,6] ?
</code></pre>

<p>So the <code>append XS YS ZS</code> predicate takes three lists as arguments; the first two, <code>XS</code>, <code>YS</code>, are
the operands, and <code>ZS</code>, the last one, is the result of the append. However, the predicate can be
used not only to find the result of appending a fully-known <code>YS</code> to <code>XS</code>, but also to discover the
value of <code>XS</code> or <code>YS</code> given the other operand and the result. Here is the type of <code>append</code>:</p>

<pre><code class="language-makam-noeval">append : (XS: list int) (YS: list int) (ZS: list int) -&gt; prop.
</code></pre>

<p>The name of the type <code>prop</code> comes from <em>proposition</em>: these are the statements that we can query
upon, and might be viewed as the logic programming equivalent of the <em>expressions</em> of a functional
programming language. So a fully applied predicate like <code>append XS YS ZS</code> is a proposition, and by
querying about it as we did above, we are asking the Makam interpreter to find an instantiation for
the unknown <em>unification variables</em> that makes the proposition hold.</p>

<p>The <code>append</code> queries above might be surprising at first, so let&rsquo;s see how <code>append</code> is implemented.
In logic programming, we implement a predicate by defining its <em>rules</em>: basically, we define the cases for
which a certain proposition, like <code>append XS YS ZS</code> holds. Each rule has a <em>goal</em> and optional <em>premises</em>,
written roughly as <code>goal :- premises</code> (note the &ldquo;<code>:-</code>&rdquo; which can be read as <strong>&ldquo;when&rdquo;</strong>). The way
these rules are executed is like this: given the current query <code>Q</code> that we are trying to solve, we
attempt to unify it with the goal of each rule; if unification is successful, we proceed to the
premises, treating them as subsequent queries that need to be satisfied.</p>

<p>The rules that make up <code>append</code> are these:</p>

<pre><code class="language-makam-noeval">append [] YS YS.
append (X :: XS) YS (X :: XSYS) :- append XS YS XSYS.
</code></pre>

<p>The first rule says: appending <code>YS</code> to an empty list results in <code>YS</code>. The second rule says:
appending <code>YS</code> to a list that has <code>X</code> as a head and <code>XS</code> as tails results in a list with <code>X</code>
as a head and <code>XSYS</code> as a tail, <strong>when</strong> appending <code>YS</code> to <code>XS</code> results in <code>XSYS</code>.</p>

<p>It&rsquo;s a good exercise to try to convince yourself <em>why</em> the queries we saw above actually work,
based on the small explanation I gave of how rules are executed. There really is not a lot of
magic going on!</p>

<p>One might ask — why is it useful to have a language that relies on unification and relations instead
of functions? One example is that when implementing a type checking procedure for a language,
blurring the line between inputs and outputs allows us to get a type inferencing procedure
essentially for free. But that is getting too much ahead of ourselves; we will see more in later
posts.</p>

<p>With this out of the way, it is time to try our hand at writing our first predicate over the
expressions we defined.</p>

<h1 id="writing-an-interpreter-for-our-language">Writing an interpreter for our language</h1>

<p>Let&rsquo;s go back to implementing our toy language now. Here is the base declaration of a predicate that
relates an expression of our language with the value it will result in upon evaluation. We can use
this predicate as an interpreter, if we give it a complete expression and a fully unknown value as
arguments.</p>

<pre><code class="language-makam">eval : (E: expr) (V: expr) -&gt; prop.
</code></pre>

<p>Here&rsquo;s how we would use this, to evaluate/interpret a small example program:</p>

<pre><code class="language-makam">eval (add (intconst 1) (intconst 2)) Value ?
</code></pre>

<p>Of course, this query fails at this point, as we have not given any kind of implementation for the
<code>eval</code> predicate. So let&rsquo;s start with adding some rules to evaluate integer constants and integer
addition:</p>

<pre><code class="language-makam">eval (intconst I) (intconst I).
eval (add E1 E2) (intconst N) :-
  eval E1 (intconst N1),
  eval E2 (intconst N2),
  plus N1 N2 N.
</code></pre>

<p>(Note the distinction between <code>add</code> which is one of the constructors of expressions that we have
defined, and <code>plus</code>, which is a built-in predicate for adding integers together.)</p>

<p>The first rule says: integer constants evaluate to themselves (because they are already values).
The second one can be read as: the <code>add</code> expression evaluates to an integer constant <code>N</code>, <em>when</em>
the two operands evaluate to the integer constants <code>N1</code> and <code>N2</code>, and we also have <code>N = N1 + N2</code>.
With these two rules, the query from above should now work:</p>

<pre><code class="language-makam">eval (add (intconst 1) (intconst 2)) Value ?
</code></pre>

<pre><code class="language-makam-hidden">&gt;&gt; Yes:
&gt;&gt; Value := intconst 3.
</code></pre>

<p>(Note that in a functional language when defining a function by pattern-matching, we <em>have</em> to give
its full definition. In logic programming, we can add new rules for a predicate at any point of our
program, similarly to how we can add new constructors at any point.)</p>

<p>Let&rsquo;s also add the cases for boolean constants, string constants and appending strings together. For
the latter one, we can use the Makam builtin string predicate <code>string.append</code>:</p>

<pre><code class="language-makam">eval (boolconst B) (boolconst B).
eval (stringconst S) (stringconst S).
eval (add E1 E2) (stringconst S) :-
  eval E1 (stringconst S1),
  eval E2 (stringconst S2),
  string.append S1 S2 S.
</code></pre>

<p>Let&rsquo;s try a couple more queries:</p>

<pre><code class="language-makam">eval (add (stringconst &quot;foo&quot;) (stringconst &quot;bar&quot;)) V ?
eval (add (intconst 5) (stringconst &quot;foo&quot;)) V ?
</code></pre>

<pre><code class="language-makam-hidden">eval (add (stringconst &quot;foo&quot;) (stringconst &quot;bar&quot;)) V ?
&gt;&gt; Yes:
&gt;&gt; V := stringconst &quot;foobar&quot;.

eval (add (intconst 5) (stringconst &quot;foo&quot;)) V ?
&gt;&gt; Impossible.
</code></pre>

<p>Of course, the last query fails, as it should: we have only defined rules to handle the case where
the operands to <code>add</code> evaluate to the same type of constant. That could be a deliberate choice
depending on how we want evaluation in our language to behave.</p>

<p>How about arrays? For an array like <code>[1 + 2, &quot;foo&quot; + &quot;bar&quot;]</code>, every member of the array needs to
be evaluated. We can describe this using two rules:</p>

<pre><code class="language-makam">eval (array []) (array []).

eval (array (HeadExpr :: TailExprs))
     (array (HeadVal :: TailVals)) :-
  eval HeadExpr HeadVal, eval (array TailExprs) (array TailVals).
</code></pre>

<p>Let&rsquo;s try this out:</p>

<pre><code class="language-makam">eval (array [
       add (intconst 1) (intconst 2),
       add (stringconst &quot;foo&quot;) (stringconst &quot;bar&quot;)])
     Value ?
</code></pre>

<pre><code class="language-makam-hidden">&gt;&gt; Yes:
&gt;&gt; Value := array [ intconst 3, stringconst &quot;foobar&quot; ].
</code></pre>

<p>(As an aside — we can do better than this. Remember when we said that Makam is a <em>higher-order</em> logic
programming language? That means that we can define higher-order predicates — predicates that
take other predicates as arguments — similarly to how we can define higher-order functions
in a higher-order functional programming language. One example of such a predicate is <code>map</code>
for lists, which is defined as follows in the Makam standard library:</p>

<pre><code class="language-makam-noeval">map Pred [] [].
map Pred (X :: XS) (Y :: YS) :- Pred X Y, map Pred XS YS.
</code></pre>

<p>The evaluation rule for arrays would then be:</p>

<pre><code class="language-makam-noeval">eval (array Exprs) (array Vals) :- map eval Exprs Vals.
</code></pre>

<p>More on this on a later installment.)</p>

<p>Evaluating records is a little more complicated. We need to evaluate the expressions contained
within them, so that <code>{ foo: 1 + 1, bar: 2 + 2 }</code> evaluates to <code>{ foo: 2, bar: 4 }</code>. However, we
also need to decide what to do about duplicate key entries, as in <code>{ foo: 1, foo: 2 }</code>. For that, we
will follow the JavaScript semantics for objects: duplicate entries for the same key are allowed,
and the last occurrence of the same key is the one that gets picked — so the previous object
evaluates to <code>{ foo: 2 }</code>. We won&rsquo;t follow the JavaScript semantics when it comes to ordering the
fields: instead, we will maintain the order of that appears in the source.</p>

<p>Let&rsquo;s see how to implement this in Makam. Here&rsquo;s a first attempt where we
do not handle duplicate keys properly:</p>

<pre><code class="language-makam-noeval">eval (record []) (record []).
eval (record (mkfield Key Expr :: Rest))
     (record (mkfield Key Value :: Rest')) :-
  eval Expr Value,
  eval (record Rest) (record Rest').
</code></pre>

<p>To account for duplicate keys, we need to split this last rule into two: one for the last occurrence
of a key (where the key does not appear in subsequent fields) and one for any earlier
occurrences. In this second case, the field can safely be ignored, as the language we are encoding
does not have any side effects. To distinguish the two cases, we can use an auxiliary predicate
<code>contains_key</code> (so a new <code>prop</code>), that succeeds whenever a key exists within a list of fields:</p>

<pre><code class="language-makam">contains_key : (Fields: list field) (Key: string) -&gt; prop.
contains_key (mkfield Key Expr :: Rest) Key.
contains_key (Field :: Rest) Key :-
  contains_key Rest Key.
</code></pre>

<p>And here&rsquo;s the rules for evaluation:</p>

<pre><code class="language-makam">eval (record []) (record []).
eval (record (mkfield Key Expr :: Rest))
     (record Rest') :-
  contains_key Rest Key,
  eval (record Rest) (record Rest').
eval (record (mkfield Key Expr :: Rest))
     (record (mkfield Key Value :: Rest')) :-
  not(contains_key Rest Key),
  eval Expr Value, eval (record Rest) (record Rest').
</code></pre>

<p>Note the use of <code>not</code> here: basically, we are saying that this last rule applies whenever
<code>contains_key Rest Key</code> is not successful<sup class="footnote-ref" id="fnref:1"><a rel="footnote" href="#fn:1">1</a></sup>.</p>

<p>With these, the interpreter for our toy language is complete!</p>

<pre><code class="language-makam">eval (record [
  mkfield &quot;foo&quot; (add (intconst 1) (intconst 1)),
  mkfield &quot;bar&quot; (array [ add (intconst 2) (intconst 2) ]),
  mkfield &quot;foo&quot; (add (intconst 4) (intconst 4))
]) V ?
</code></pre>

<pre><code class="language-makam-hidden">&gt;&gt; Yes:
&gt;&gt; V := record [mkfield &quot;bar&quot; (array [intconst 4]), mkfield &quot;foo&quot; (intconst 8)].
</code></pre>

<h1 id="defining-the-concrete-syntax-for-our-language">Defining the concrete syntax for our language</h1>

<p>One issue with our interpreter, which is quite evident in the query above, is that we have to use
abstract syntax for writing down the terms of our language — and that&rsquo;s not always pleasant.
Abstract syntax is often quite long-winded and verbose, even for simple terms.  It would be
nice to be able to use concrete syntax instead, to write queries like:</p>

<pre><code class="language-makam-noeval">evalstring &lt;&lt; { &quot;foo&quot;: &quot;a&quot;, &quot;foo&quot;: [ &quot;bar&quot;, 40 + 2 ] } &gt;&gt; Y ?
</code></pre>

<p>(The syntax form <code>&lt;&lt; .. &gt;&gt;</code> is alternative syntax for strings in Makam, so that we don&rsquo;t have to
escape the quotes <code>&quot;</code> within it.)</p>

<p>What we need is a parser, that converts a <code>string</code> containing concrete syntax into the abstract
syntax terms that we have defined. So we need to define a predicate with the type:</p>

<pre><code class="language-makam-noeval">parse_expr : (Concrete: string) (Abstract: expr) -&gt; prop.
</code></pre>

<p>Let&rsquo;s ruminate on this: given a query on <code>parse_expr</code>, what would happen if the second argument was a
fully-known abstract syntax tree, whereas the first argument was fully unknown? In that case, we would
be reconstructing the concrete syntax of an abstract syntax tree — namely, we would be using this
predicate as a pretty-printer for our terms.<sup class="footnote-ref" id="fnref:2"><a rel="footnote" href="#fn:2">2</a></sup> So maybe <code>parse_expr</code> is not such a great name for our
predicate, since we could use it both as a parser and a pretty-printer of expressions.</p>

<p>How about writing the predicate itself? Makam already has a <code>syntax</code> library that can help us
implement syntax predicates like these by only giving a grammar for our language, similar to how
parser generators are used in other languages. I will give an example of how to use it for the language we have defined in this post, and will
just say that the parsing aspect of the library is based
on <a href="https://pdos.csail.mit.edu/papers/parsing:popl04.pdf">PEG parsing</a><sup class="footnote-ref" id="fnref:3"><a rel="footnote" href="#fn:3">3</a></sup> and I am using an
adaptation
of
<a href="http://www.mathematik.uni-marburg.de/~rendel/rendel10invertible.pdf">Invertible Syntax Descriptions</a><sup class="footnote-ref" id="fnref:4"><a rel="footnote" href="#fn:4">4</a></sup>
to the PEG setting so that the same grammar is used both for parsing and pretty printing.</p>

<p>Before looking at the code, let me briefly explain the components that go into it. First, we
need to define &ldquo;syntax constructors&rdquo; which are akin to typed non-terminals in grammars: for example,
a syntax constructor with the type <code>syntax expr</code> will be used as a handle that allows us to parse
and pretty-print terms of type <code>expr</code>. Then, we need to give syntactic rules, which describe how to
parse/pretty-print each term constructor (like <code>stringconst</code>, <code>array</code>, etc.). Last, we need to generate
parsing/pretty-printing code for each toplevel syntax constructor; this is akin to running a parser
generator to get the parsing code for our grammar. This step, just as all the other steps, happens
within the same Makam program instead of requiring an external parser generator.</p>

<pre><code class="language-makam-hidden">%open syntax.
</code></pre>

<pre><code class="language-makam">baseexpr, expr : syntax expr.
field : syntax field.

`(syntax_rules &lt;&lt;

  expr -&gt;
    add         { &lt;baseexpr&gt; &quot;+&quot; &lt;expr&gt; }
  / baseexpr ;

  baseexpr -&gt;
    stringconst { &lt;makam.string_literal&gt; }
  / intconst    { &lt;makam.int_literal&gt; }
  / array       { &quot;[&quot; &lt;list_sep (token &quot;,&quot;) expr&gt; &quot;]&quot; }
  / record      { &quot;{&quot; &lt;list_sep (token &quot;,&quot;) field&gt; &quot;}&quot; }
  / { &quot;(&quot; &lt;expr&gt; &quot;)&quot; } ;

  field -&gt;
    mkfield     { &lt;makam.ident&gt; &quot;:&quot; &lt;expr&gt; }
  / mkfield     { &lt;makam.string_literal&gt; &quot;:&quot; &lt;expr&gt; }

&gt;&gt;).
`( syntax.def_toplevel_js expr ).
</code></pre>

<p>Let&rsquo;s try out parsing and pretty-printing. We will use the <code>syntax.run</code> predicate, which does
either of these two depending on its arguments:</p>

<pre><code class="language-makam">syntax.run expr &quot;{ foo: 1, bar: 2 + 2 }&quot; Expr ?
syntax.run expr String (record [ mkfield &quot;foo&quot; (intconst 5) ]) ?
</code></pre>

<pre><code class="language-makam-hidden">&gt;&gt; syntax.run expr &quot;{ foo: 1, bar: 2 + 2 }&quot; Expr ?
&gt;&gt; Yes:
&gt;&gt; Expr := record [ mkfield &quot;foo&quot; (intconst 1), mkfield &quot;bar&quot; (add (intconst 2) (intconst 2)) ].

&gt;&gt; syntax.run expr String (record [ mkfield &quot;foo&quot; (intconst 5) ]) ?
&gt;&gt; Yes:
&gt;&gt; String := &quot;{ foo : 5 } &quot;.
</code></pre>

<p>OK, let&rsquo;s unpack the code above a bit and explain what goes into it. The toplevel syntax constructor
is <code>expr</code>, which we will use to parse and pretty-print expressions of our language. We also make use
of two additional auxiliary syntaxes, one for base expressions and one for fields. <code>expr</code> represents
the higher-precedence part of expressions — right now, this just stands for infix addition — while
base expressions are the lower-precedence ones, which is everything else. The syntax library does
not presently include any explicit support for describing precedence, and that&rsquo;s why we had to split
into top-level and base expressions manually. Each syntax rule specifies the constructor that it is
parsing/pretty-printing, along with any number of tokens and other syntax expressions that are
needed. Each expression within the angle brackets needs to correspond to the type of each argument
of the constructor: for example, in the first rule for the <code>mkfield</code> constructor, which requires a
string followed by an expression, <code>makam.ident</code> is a syntax constructor of type <code>syntax string</code> and
<code>expr</code> is of type <code>syntax expr</code>.  The <code>list_sep</code> incantation for <code>array</code> and <code>record</code> is used to
parse/pretty-print a list with the specified separator, which here is the <code>&quot;,&quot;</code> token.</p>

<p>One thing to note about the workings of these rules is that contrary to context-free grammars, the rules
here are applied in order and the choice is deterministic: given two rules like <code>A / B</code>, we attempt to
parse/pretty-print using <code>A</code>, and only if that fails <code>B</code> is attempted. This has implications both for
parsing and pretty-printing: for example, if we switch the order of rules for <code>expr</code>, we will never get
to the rule for <code>add</code> when parsing, as <code>baseexpr</code> is already parseable on its own, and that&rsquo;s the first
prerequisite for <code>add</code>. For pretty-printing, the order of rules means that a record will be
printed as <code>{ foo: ... }</code> instead of <code>{ &quot;foo&quot;: ... }</code> for keys that are identifiers; the string notation
will be used otherwise. Another note is that left recursion is not permitted, hence we could
not have a rule for <code>add</code> like <code>&lt;expr&gt; &quot;+&quot; &lt;expr&gt;</code> but need to break the recursion through <code>baseexpr</code>.</p>

<p>Last, one small note for the syntax of Makam itself and how these definitions actually work: the
`<code>(</code> notation stands for a call to a staging predicate: that is, a predicate that generates further
Makam code that is &ldquo;inserted&rdquo; in place. Here, <code>syntax_rules</code> transforms these grammar rules (given
as a plain string with the notation <code>&lt;&lt; .. &gt;&gt;</code>) into normal Makam rules that define parsing and
pretty-printing; whereas <code>syntax.def_toplevel_js</code> generates some JavaScript code that is then inserted
into a normal Makam predicate that will be used for parsing.</p>

<p>With <code>syntax.run expr</code> defined, we can now define a predicate that is more akin
to the input-output portion of a REPL for our language, that takes an expression as
a concrete string as input, evaluates it and returns the result as a string again:</p>

<pre><code class="language-makam">evalstring : (ExprStr: string) (ValueStr: string) -&gt; prop.
evalstring ExprStr ValueStr :-
  syntax.run expr ExprStr Expr,
  eval Expr Value,
  syntax.run expr ValueStr Value.
</code></pre>

<p>So what we do is that we first parse the concrete string; evaluate the expression
to a value; and pretty-print the resulting value into concrete syntax.</p>

<p>We can now issue queries to try out our whole implementation so far. Note that
this query block is editable, so you can try your own queries as well:</p>

<pre><code class="language-makam-input">evalstring &lt;&lt; { &quot;foo&quot;: &quot;a&quot;, &quot;foo&quot;: [ &quot;bar&quot;, 40 + 2 ] } &gt;&gt; X ?
evalstring &lt;&lt; [ 1 + (12 + 12) ] &gt;&gt; X ?
</code></pre>

<pre><code class="language-makam-hidden">&gt;&gt; evalstring &lt;&lt; { &quot;foo&quot;: &quot;a&quot;, &quot;foo&quot;: [ &quot;bar&quot;, 40 + 2 ] } &gt;&gt; X ?
&gt;&gt; Yes:
&gt;&gt; X := &quot;{ foo : [ \&quot;bar\&quot; , 42 ] } &quot;.

&gt;&gt; evalstring &lt;&lt; [ 1 + (12 + 12) ] &gt;&gt; X ?
&gt;&gt; Yes:
&gt;&gt; X := &quot;[ 25 ] &quot;.
</code></pre>

<h1 id="conclusion">Conclusion</h1>

<p>We did cover quite a bit of stuff here: concrete and abstract syntax, the very basics of computation
in logic programming, and writing an interpreter for a very simple language. Next time we will cover
how to encode more complicated constructs, like functions, how to implement a type checker for our
language in Makam, and more on the basics of higher-order logic programming.</p>
<div class="footnotes">

<hr />

<ol>
<li id="fn:1">Negation in logic programming languages is a big topic, mostly because it breaks many of the invariants that hold about the language otherwise. For example: adding a new rule only makes more queries succeed, instead of making queries fail when they were previously succeeding; this does not hold in the presence of negation.
 <a class="footnote-return" href="#fnref:1"><sup>[return]</sup></a></li>
<li id="fn:2">The reality is more complicated of course — using the same predicate for both kinds of queries is not always possible for free, or will not always terminate. In a later post, we will explore this more in-depth.
 <a class="footnote-return" href="#fnref:2"><sup>[return]</sup></a></li>
<li id="fn:3">Bryan Ford. 2004. <em>Parsing expression grammars: a recognition-based syntactic foundation</em>. In Proceedings of the 31st ACM SIGPLAN-SIGACT symposium on Principles of programming languages (POPL &lsquo;04). ACM, New York, NY, USA, 111-122. DOI: <a href="http://dx.doi.org/10.1145/964001.964011">http://dx.doi.org/10.1145/964001.964011</a>
 <a class="footnote-return" href="#fnref:3"><sup>[return]</sup></a></li>
<li id="fn:4">Tillmann Rendel and Klaus Ostermann. 2010. <em>Invertible syntax descriptions: unifying parsing and pretty printing</em>. In Proceedings of the third ACM Haskell symposium on Haskell (Haskell &lsquo;10). ACM, New York, NY, USA, 1-12. DOI: <a href="https://doi.org/10.1145/1863523.1863525">https://doi.org/10.1145/1863523.1863525</a>
 <a class="footnote-return" href="#fnref:4"><sup>[return]</sup></a></li>
</ol>
</div>

            </div>
        </div>
	</div>
    <div class="pure-u-1-24 pure-u-md-1-4"></div>
</div>


<div class="footer pure-g">
    <div class="pure-u-1-24 pure-u-md-5-24"></div>
    <div class="pure-u-11-12 pure-u-md-5-8">
        <div class="pure-menu pure-menu-horizontal footer-content">

            <a href="#" class="pure-menu-heading pull-right" id="gototop-btn">↑ TOP</a>
        </div>
	  </div>
      <div class="pure-u-1-24 pure-u-md-1-6"></div>
</div>


<script src="https://astampoulis.github.io/js/jquery.min.js" type="text/javascript"></script>
<script src="https://astampoulis.github.io/js/jquery.timeago.js" type="text/javascript"></script>




<script type="text/javascript">
  $(function(){
    $("time.timeago").timeago();
  })
  $("#toggle-btn").click(function(){
    $("#toggle-content").toggle();
    if($(this).html() === "☰") {
        $(this).html("X")
    } else {
        $(this).html("☰")
    }
  });
  $(window).resize(function(){
    if(window.innerWidth > 768) {
      $(".desktop").removeAttr("style");
    }
  });
</script>

<script async src="https://www.googletagmanager.com/gtag/js?id=UA-1328981-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-1328981-1');
</script>
</div>
</body>
</html>

